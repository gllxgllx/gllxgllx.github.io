<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>高频八股总结2 | 格 致</title><meta name="author" content="怪陆离辛"><meta name="copyright" content="怪陆离辛"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP和UDP的区别TCP（Transmission Control Protocol） 和 UDP（User Datagram Protocol） 是两种常用的传输层协议，它们在数据传输方式、可靠性和适用场景等方面有显著区别。以下是它们的详细对比：  1. 连接方式• TCP：  • 面向连接，需要先建立连接（三次握手），再传输数据，传输完成后断开连接（四次挥手）。  • 适用于需要可靠传输的场">
<meta property="og:type" content="article">
<meta property="og:title" content="高频八股总结2">
<meta property="og:url" content="http://example.com/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/index.html">
<meta property="og:site_name" content="格 致">
<meta property="og:description" content="TCP和UDP的区别TCP（Transmission Control Protocol） 和 UDP（User Datagram Protocol） 是两种常用的传输层协议，它们在数据传输方式、可靠性和适用场景等方面有显著区别。以下是它们的详细对比：  1. 连接方式• TCP：  • 面向连接，需要先建立连接（三次握手），再传输数据，传输完成后断开连接（四次挥手）。  • 适用于需要可靠传输的场">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/12.png">
<meta property="article:published_time" content="2025-03-08T07:44:45.000Z">
<meta property="article:modified_time" content="2025-03-08T08:58:26.898Z">
<meta property="article:author" content="怪陆离辛">
<meta property="article:tag" content="春招">
<meta property="article:tag" content="八股">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/12.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高频八股总结2',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-08 16:58:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/mycss.css"><link rel="stylesheet" href="/css/xxx.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/mouse.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_1.css" ><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/zyoushuo/Blog@latest/hexo/css/loading_style_2.css" ><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="wizard-scene"><div class="wizard-objects"><div class="wizard-square"></div><div class="wizard-circle"></div><div class="wizard-triangle"></div></div><div class="wizard"><div class="wizard-body"></div><div class="wizard-right-arm"><div class="wizard-right-hand"></div></div><div class="wizard-left-arm"><div class="wizard-left-hand"></div></div><div class="wizard-head"><div class="wizard-beard"></div><div class="wizard-face"><div class="wizard-adds"></div></div><div class="wizard-hat"><div class="wizard-hat-of-the-hat"></div><div class="wizard-four-point-star --first"></div><div class="wizard-four-point-star --second"></div><div class="wizard-four-point-star --third"></div></div></div></div></div></div><script async="async"> var preloader = {
   endLoading: () => {
     document.body.style.overflow = 'auto';
     document.getElementById('loading-box').classList.add("loaded")
   },
   initLoading: () => {
     document.body.style.overflow = '';
     document.getElementById('loading-box').classList.remove("loaded")

   }
 }
setTimeout(function(){preloader.endLoading();}, 3000);</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-braille"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-beer"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 相关</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/12.png')"><nav id="nav"><span id="blog-info"><a href="/" title="格 致"><span class="site-name">格 致</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-book"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 归档</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-braille"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/gallery/"><i class="fa-fw fa fa-images"></i><span> 番剧</span></a></li><li><a class="site-page child" href="/bangumis/"><i class="fa-fw fa fa-beer"></i><span> 追番</span></a></li></ul></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 菜单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/about/"><i class="fa-fw fa fa-sitemap"></i><span> 相关</span></a></li><li><a class="site-page child" href="/myself/"><i class="fa-fw fa fa-id-card"></i><span> 关于我</span></a></li><li><a class="site-page child" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></li><li><a class="site-page child" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></li><li><a class="site-page child" href="/timeline/"><i class="fa-fw fa fa-bell"></i><span> 日志</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">高频八股总结2</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-08T07:44:45.000Z" title="发表于 2025-03-08 15:44:45">2025-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-08T08:58:26.898Z" title="更新于 2025-03-08 16:58:26">2025-03-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="高频八股总结2"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="TCP和UDP的区别"><a href="#TCP和UDP的区别" class="headerlink" title="TCP和UDP的区别"></a>TCP和UDP的区别</h1><p><strong>TCP（Transmission Control Protocol）</strong> 和 <strong>UDP（User Datagram Protocol）</strong> 是两种常用的传输层协议，它们在数据传输方式、可靠性和适用场景等方面有显著区别。以下是它们的详细对比：</p>
<hr>
<h3 id="1-连接方式"><a href="#1-连接方式" class="headerlink" title="1. 连接方式"></a><strong>1. 连接方式</strong></h3><p>• <strong>TCP</strong>：<br>  • 面向连接，需要先建立连接（三次握手），再传输数据，传输完成后断开连接（四次挥手）。<br>  • 适用于需要可靠传输的场景。<br>• <strong>UDP</strong>：<br>  • 无连接，直接发送数据，不需要建立连接。<br>  • 适用于对实时性要求高的场景。</p>
<hr>
<h3 id="2-可靠性"><a href="#2-可靠性" class="headerlink" title="2. 可靠性"></a><strong>2. 可靠性</strong></h3><p>• <strong>TCP</strong>：<br>  • 提供可靠的数据传输，通过确认机制、重传机制、流量控制和拥塞控制确保数据不丢失、不重复、按序到达。<br>  • 适用于对数据完整性要求高的场景，如文件传输、邮件发送等。<br>• <strong>UDP</strong>：<br>  • 不保证可靠性，数据可能丢失、重复或乱序。<br>  • 适用于对实时性要求高、允许少量数据丢失的场景，如视频流、在线游戏等。</p>
<hr>
<h3 id="3-数据传输方式"><a href="#3-数据传输方式" class="headerlink" title="3. 数据传输方式"></a><strong>3. 数据传输方式</strong></h3><p>• <strong>TCP</strong>：<br>  • 基于字节流，将数据分成多个数据包按序传输，接收端按序重组。<br>  • 适合传输大量数据。<br>• <strong>UDP</strong>：<br>  • 基于数据报，每个数据包独立传输，不保证顺序。<br>  • 适合传输少量数据。</p>
<hr>
<h3 id="4-传输效率"><a href="#4-传输效率" class="headerlink" title="4. 传输效率"></a><strong>4. 传输效率</strong></h3><p>• <strong>TCP</strong>：<br>  • 由于需要建立连接、确认机制和重传机制，传输效率较低。<br>  • 适合对可靠性要求高的场景。<br>• <strong>UDP</strong>：<br>  • 无连接、无确认机制，传输效率较高。<br>  • 适合对实时性要求高的场景。</p>
<hr>
<h3 id="5-头部开销"><a href="#5-头部开销" class="headerlink" title="5. 头部开销"></a><strong>5. 头部开销</strong></h3><p>• <strong>TCP</strong>：<br>  • 头部较大（20 字节），包含序列号、确认号、窗口大小等信息。<br>  • 适合传输大量数据。<br>• <strong>UDP</strong>：<br>  • 头部较小（8 字节），仅包含源端口、目标端口、长度和校验和。<br>  • 适合传输少量数据。</p>
<hr>
<h3 id="6-适用场景"><a href="#6-适用场景" class="headerlink" title="6. 适用场景"></a><strong>6. 适用场景</strong></h3><p>• <strong>TCP</strong>：<br>  • 文件传输（如 FTP、HTTP）。<br>  • 邮件发送（如 SMTP、POP3）。<br>  • 网页浏览（如 HTTPS）。<br>  • 数据库访问。<br>• <strong>UDP</strong>：<br>  • 实时视频流（如直播、视频会议）。<br>  • 在线游戏。<br>  • 域名解析（如 DNS）。<br>  • 广播和多播应用。</p>
<hr>
<h3 id="7-典型协议"><a href="#7-典型协议" class="headerlink" title="7. 典型协议"></a><strong>7. 典型协议</strong></h3><p>• <strong>TCP</strong>：<br>  • HTTP、HTTPS、FTP、SMTP、POP3、Telnet、SSH 等。<br>• <strong>UDP</strong>：<br>  • DNS、DHCP、SNMP、TFTP、RTP（实时传输协议）等。</p>
<hr>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody><tr>
<td><strong>连接方式</strong></td>
<td>面向连接（三次握手、四次挥手）</td>
<td>无连接</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>可靠（确认、重传、流量控制、拥塞控制）</td>
<td>不可靠（可能丢失、重复、乱序）</td>
</tr>
<tr>
<td><strong>数据传输方式</strong></td>
<td>基于字节流</td>
<td>基于数据报</td>
</tr>
<tr>
<td><strong>传输效率</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>头部开销</strong></td>
<td>较大（20 字节）</td>
<td>较小（8 字节）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>文件传输、邮件发送、网页浏览、数据库访问</td>
<td>实时视频流、在线游戏、域名解析、广播应用</td>
</tr>
<tr>
<td><strong>典型协议</strong></td>
<td>HTTP、HTTPS、FTP、SMTP 等</td>
<td>DNS、DHCP、SNMP、RTP 等</td>
</tr>
</tbody></table>
<p>根据具体需求选择合适的协议：<br>• 如果需要可靠传输，选择 <strong>TCP</strong>。<br>• 如果需要高效传输，选择 <strong>UDP</strong>。</p>
<h1 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h1><p><strong>HTTP（HyperText Transfer Protocol）</strong> 和 <strong>HTTPS（HyperText Transfer Protocol Secure）</strong> 是用于在客户端和服务器之间传输数据的协议，它们在安全性、性能和实现方式等方面有显著区别。以下是它们的详细对比：</p>
<hr>
<h3 id="1-安全性"><a href="#1-安全性" class="headerlink" title="1. 安全性"></a><strong>1. 安全性</strong></h3><p>• <strong>HTTP</strong>：<br>  • 数据以明文形式传输，容易被窃听、篡改或伪造。<br>  • 不提供数据加密和身份验证机制。<br>• <strong>HTTPS</strong>：<br>  • 数据通过 SSL&#x2F;TLS 协议加密传输，防止窃听、篡改和伪造。<br>  • 提供服务器身份验证，确保客户端连接到正确的服务器。</p>
<hr>
<h3 id="2-协议与端口"><a href="#2-协议与端口" class="headerlink" title="2. 协议与端口"></a><strong>2. 协议与端口</strong></h3><p>• <strong>HTTP</strong>：<br>  • 基于 TCP 协议。<br>  • 默认端口为 <strong>80</strong>。<br>• <strong>HTTPS</strong>：<br>  • 基于 TCP 协议，并在其上增加了 SSL&#x2F;TLS 加密层。<br>  • 默认端口为 <strong>443</strong>。</p>
<hr>
<h3 id="3-性能"><a href="#3-性能" class="headerlink" title="3. 性能"></a><strong>3. 性能</strong></h3><p>• <strong>HTTP</strong>：<br>  • 由于没有加密和解密过程，性能较高，延迟较低。<br>• <strong>HTTPS</strong>：<br>  • 由于增加了 SSL&#x2F;TLS 加密和解密过程，性能较低，延迟较高。<br>  • 现代硬件和优化技术（如 HTTP&#x2F;2、TLS 1.3）已经显著减少了 HTTPS 的性能开销。</p>
<hr>
<h3 id="4-证书"><a href="#4-证书" class="headerlink" title="4. 证书"></a><strong>4. 证书</strong></h3><p>• <strong>HTTP</strong>：<br>  • 不需要证书。<br>• <strong>HTTPS</strong>：<br>  • 需要由受信任的证书颁发机构（CA）签发的 SSL&#x2F;TLS 证书。<br>  • 证书用于验证服务器身份和加密数据传输。</p>
<hr>
<h3 id="5-应用场景"><a href="#5-应用场景" class="headerlink" title="5. 应用场景"></a><strong>5. 应用场景</strong></h3><p>• <strong>HTTP</strong>：<br>  • 适用于不涉及敏感数据的场景，如静态网站、新闻网站等。<br>• <strong>HTTPS</strong>：<br>  • 适用于涉及敏感数据的场景，如登录认证、支付交易、用户隐私数据等。</p>
<hr>
<h3 id="6-SEO-影响"><a href="#6-SEO-影响" class="headerlink" title="6. SEO 影响"></a><strong>6. SEO 影响</strong></h3><p>• <strong>HTTP</strong>：<br>  • 搜索引擎（如 Google）对 HTTP 网站的排名较低。<br>• <strong>HTTPS</strong>：<br>  • 搜索引擎对 HTTPS 网站的排名较高，建议所有网站使用 HTTPS。</p>
<hr>
<h3 id="7-实现方式"><a href="#7-实现方式" class="headerlink" title="7. 实现方式"></a><strong>7. 实现方式</strong></h3><p>• <strong>HTTP</strong>：<br>  • 直接通过 TCP 传输数据，无需额外配置。<br>• <strong>HTTPS</strong>：<br>  • 需要在服务器上配置 SSL&#x2F;TLS 证书，并启用 HTTPS 协议。</p>
<hr>
<h3 id="8-浏览器标识"><a href="#8-浏览器标识" class="headerlink" title="8. 浏览器标识"></a><strong>8. 浏览器标识</strong></h3><p>• <strong>HTTP</strong>：<br>  • 浏览器地址栏显示为 <code>http://</code>，没有安全标识。<br>• <strong>HTTPS</strong>：<br>  • 浏览器地址栏显示为 <code>https://</code>，并带有锁图标，表示连接安全。</p>
<hr>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a><strong>总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>HTTP</th>
<th>HTTPS</th>
</tr>
</thead>
<tbody><tr>
<td><strong>安全性</strong></td>
<td>不加密，明文传输</td>
<td>加密传输，防止窃听、篡改和伪造</td>
</tr>
<tr>
<td><strong>协议与端口</strong></td>
<td>基于 TCP，端口 80</td>
<td>基于 TCP + SSL&#x2F;TLS，端口 443</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较高，延迟较低</td>
<td>较低，延迟较高（现代优化已减少开销）</td>
</tr>
<tr>
<td><strong>证书</strong></td>
<td>不需要</td>
<td>需要 SSL&#x2F;TLS 证书</td>
</tr>
<tr>
<td><strong>应用场景</strong></td>
<td>不涉及敏感数据的场景</td>
<td>涉及敏感数据的场景</td>
</tr>
<tr>
<td><strong>SEO 影响</strong></td>
<td>排名较低</td>
<td>排名较高</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>直接通过 TCP 传输</td>
<td>需要配置 SSL&#x2F;TLS 证书</td>
</tr>
<tr>
<td><strong>浏览器标识</strong></td>
<td>显示 <code>http://</code>，无安全标识</td>
<td>显示 <code>https://</code>，带有锁图标</td>
</tr>
</tbody></table>
<hr>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a><strong>建议</strong></h3><p>• 对于所有网站，尤其是涉及用户隐私、登录认证或支付交易的网站，建议使用 <strong>HTTPS</strong>。<br>• 现代浏览器和搜索引擎已经广泛支持 HTTPS，并且 HTTPS 的性能开销在现代硬件和优化技术下已经显著降低。</p>
<h1 id="快速排序的思路"><a href="#快速排序的思路" class="headerlink" title="快速排序的思路"></a>快速排序的思路</h1><p><strong>快速排序（Quick Sort）</strong> 是一种高效的排序算法，采用分治法（Divide and Conquer）策略。它的核心思想是通过选择一个基准元素（pivot），将数组分为两部分，使得左边部分的元素都小于基准元素，右边部分的元素都大于基准元素，然后递归地对左右两部分进行排序。</p>
<p>以下是快速排序的详细思路：</p>
<hr>
<h3 id="1-选择基准元素"><a href="#1-选择基准元素" class="headerlink" title="1. 选择基准元素"></a><strong>1. 选择基准元素</strong></h3><p>从数组中选择一个元素作为基准（pivot）。选择基准的方式有多种：<br>• 选择第一个元素。<br>• 选择最后一个元素。<br>• 选择中间元素。<br>• 随机选择一个元素。</p>
<hr>
<h3 id="2-分区（Partition）"><a href="#2-分区（Partition）" class="headerlink" title="2. 分区（Partition）"></a><strong>2. 分区（Partition）</strong></h3><p>将数组分为两部分：<br>• 左边部分：所有元素小于或等于基准元素。<br>• 右边部分：所有元素大于基准元素。</p>
<p>具体步骤：</p>
<ol>
<li>初始化两个指针：<code>i</code>（指向左边部分的末尾）和 <code>j</code>（遍历数组）。</li>
<li>从数组的起始位置开始遍历，如果当前元素小于或等于基准元素，则将其交换到左边部分，并移动 <code>i</code>。</li>
<li>遍历结束后，将基准元素交换到 <code>i + 1</code> 的位置，此时基准元素的位置已经确定。</li>
</ol>
<hr>
<h3 id="3-递归排序"><a href="#3-递归排序" class="headerlink" title="3. 递归排序"></a><strong>3. 递归排序</strong></h3><p>对基准元素左边的子数组和右边的子数组分别递归地进行快速排序。</p>
<hr>
<h3 id="4-终止条件"><a href="#4-终止条件" class="headerlink" title="4. 终止条件"></a><strong>4. 终止条件</strong></h3><p>当子数组的长度为 1 或 0 时，递归终止，因为单个元素已经是有序的。</p>
<hr>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a><strong>代码实现</strong></h3><p>以下是快速排序的 Java 实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">            <span class="comment">// 分区，获取基准元素的位置</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">pivotIndex</span> <span class="operator">=</span> partition(arr, low, high);</span><br><span class="line">            <span class="comment">// 递归排序左边部分</span></span><br><span class="line">            quickSort(arr, low, pivotIndex - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 递归排序右边部分</span></span><br><span class="line">            quickSort(arr, pivotIndex + <span class="number">1</span>, high);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> low, <span class="type">int</span> high)</span> &#123;</span><br><span class="line">        <span class="comment">// 选择最后一个元素作为基准</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> arr[high];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> low - <span class="number">1</span>; <span class="comment">// 左边部分的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> low; j &lt; high; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt;= pivot) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="comment">// 交换 arr[i] 和 arr[j]</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                arr[i] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将基准元素交换到正确的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i + <span class="number">1</span>];</span><br><span class="line">        arr[i + <span class="number">1</span>] = arr[high];</span><br><span class="line">        arr[high] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i + <span class="number">1</span>; <span class="comment">// 返回基准元素的位置</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">10</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        quickSort(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Sorted array: &quot;</span> + Arrays.toString(arr));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h3><p>假设数组为 <code>[10, 7, 8, 9, 1, 5]</code>：</p>
<ol>
<li>选择最后一个元素 <code>5</code> 作为基准。</li>
<li>分区后，数组变为 <code>[1, 5, 8, 9, 10, 7]</code>，基准元素 <code>5</code> 的位置为 1。</li>
<li>递归排序左边部分 <code>[1]</code> 和右边部分 <code>[8, 9, 10, 7]</code>。</li>
<li>最终得到有序数组 <code>[1, 5, 7, 8, 9, 10]</code>。</li>
</ol>
<hr>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a><strong>时间复杂度</strong></h3><p>• <strong>平均情况</strong>：(O(n \log n))。<br>• <strong>最坏情况</strong>：(O(n^2))（当数组已经有序或基准选择不当时）。</p>
<hr>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a><strong>优化</strong></h3><ol>
<li><strong>随机选择基准</strong>：避免最坏情况。</li>
<li><strong>三数取中法</strong>：选择第一个、中间和最后一个元素的中位数作为基准。</li>
<li><strong>小数组使用插入排序</strong>：当子数组长度较小时，使用插入排序。</li>
</ol>
<hr>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>快速排序通过分治法将数组分为两部分，递归地排序子数组，是一种高效的排序算法。其核心在于分区操作，合理选择基准元素可以优化性能。</p>
<h1 id="异常和错误了解吗，区别是什么"><a href="#异常和错误了解吗，区别是什么" class="headerlink" title="异常和错误了解吗，区别是什么"></a>异常和错误了解吗，区别是什么</h1><p><strong>异常（Exception）</strong> 和 <strong>错误（Error）</strong> 是 Java 中两种不同的异常类型，它们都继承自 <code>Throwable</code> 类，但在使用场景和处理方式上有显著区别。以下是它们的详细对比：</p>
<hr>
<h3 id="1-异常（Exception）"><a href="#1-异常（Exception）" class="headerlink" title="1. 异常（Exception）"></a><strong>1. 异常（Exception）</strong></h3><p>• <strong>定义</strong>：异常是程序运行时可预见的问题，通常由程序逻辑或外部条件引起，可以通过代码捕获和处理。<br>• <strong>分类</strong>：<br>  • <strong>受检异常（Checked Exception）</strong>：<br>    ◦ 必须在编译时处理（捕获或声明抛出）。<br>    ◦ 例如：<code>IOException</code>、<code>SQLException</code>。<br>  • <strong>非受检异常（Unchecked Exception）</strong>：<br>    ◦ 通常是程序逻辑错误，不强制在编译时处理。<br>    ◦ 例如：<code>NullPointerException</code>、<code>ArrayIndexOutOfBoundsException</code>。<br>• <strong>处理方式</strong>：<br>  • 使用 <code>try-catch</code> 块捕获并处理。<br>  • 使用 <code>throws</code> 关键字声明抛出。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;file.txt&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;文件未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="2-错误（Error）"><a href="#2-错误（Error）" class="headerlink" title="2. 错误（Error）"></a><strong>2. 错误（Error）</strong></h3><p>• <strong>定义</strong>：错误是程序无法处理的严重问题，通常由 JVM 或系统资源问题引起，无法通过代码捕获和处理。<br>• <strong>特点</strong>：<br>  • 错误是 <code>Throwable</code> 的子类，但程序通常无法恢复。<br>  • 例如：<code>OutOfMemoryError</code>、<code>StackOverflowError</code>。<br>• <strong>处理方式</strong>：<br>  • 无法通过代码捕获和处理，通常需要修复程序或调整系统配置。<br>• <strong>示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Example</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        recursiveMethod(); <span class="comment">// 递归调用导致栈溢出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">recursiveMethod</span><span class="params">()</span> &#123;</span><br><span class="line">        recursiveMethod(); <span class="comment">// 无限递归</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  运行结果：<br>  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Exception in thread &quot;main&quot; java.lang.StackOverflowError</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="3-区别"><a href="#3-区别" class="headerlink" title="3. 区别"></a><strong>3. 区别</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>异常（Exception）</th>
<th>错误（Error）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>定义</strong></td>
<td>程序运行时可预见的问题</td>
<td>程序无法处理的严重问题</td>
</tr>
<tr>
<td><strong>是否可恢复</strong></td>
<td>可以恢复</td>
<td>无法恢复</td>
</tr>
<tr>
<td><strong>处理方式</strong></td>
<td>可捕获和处理（<code>try-catch</code> 或 <code>throws</code>）</td>
<td>无法捕获和处理</td>
</tr>
<tr>
<td><strong>分类</strong></td>
<td>受检异常和非受检异常</td>
<td>无分类</td>
</tr>
<tr>
<td><strong>示例</strong></td>
<td><code>IOException</code>、<code>NullPointerException</code></td>
<td><code>OutOfMemoryError</code>、<code>StackOverflowError</code></td>
</tr>
<tr>
<td><strong>是否强制处理</strong></td>
<td>受检异常强制处理，非受检异常不强制</td>
<td>不强制处理</td>
</tr>
</tbody></table>
<hr>
<h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a><strong>4. 总结</strong></h3><p>• <strong>异常</strong>：程序运行时可预见的问题，可以通过代码捕获和处理，分为受检异常和非受检异常。<br>• <strong>错误</strong>：程序无法处理的严重问题，通常由 JVM 或系统资源引起，无法通过代码捕获和处理。<br>• 在实际开发中，应重点关注异常的处理，而错误通常需要从程序或系统层面解决。</p>
<h1 id="HashMap底层实现了解吗，说一下"><a href="#HashMap底层实现了解吗，说一下" class="headerlink" title="HashMap底层实现了解吗，说一下"></a>HashMap底层实现了解吗，说一下</h1><p><strong>HashMap</strong> 是 Java 中最常用的数据结构之一，用于存储键值对（Key-Value）。它的底层实现基于哈希表（Hash Table），具有高效的插入、删除和查找操作。以下是 HashMap 的底层实现原理：</p>
<hr>
<h3 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a><strong>1. 数据结构</strong></h3><p>HashMap 的底层数据结构是一个 <strong>数组 + 链表 + 红黑树</strong> 的组合：<br>• <strong>数组</strong>：用于存储桶（Bucket），每个桶是一个链表或红黑树的头节点。<br>• <strong>链表</strong>：当哈希冲突发生时，冲突的键值对会以链表的形式存储在同一个桶中。<br>• <strong>红黑树</strong>：当链表长度超过一定阈值（默认是 8），链表会转换为红黑树，以提高查找效率。</p>
<hr>
<h3 id="2-核心属性"><a href="#2-核心属性" class="headerlink" title="2. 核心属性"></a><strong>2. 核心属性</strong></h3><p>• **<code>Node&lt;K,V&gt;[] table</code>**：存储桶的数组，每个桶是一个链表或红黑树的头节点。<br>• **<code>int size</code>**：HashMap 中键值对的数量。<br>• **<code>int threshold</code>**：扩容阈值，当 <code>size</code> 超过 <code>threshold</code> 时，HashMap 会进行扩容。<br>• **<code>float loadFactor</code>**：负载因子，默认是 0.75，用于计算 <code>threshold</code>（<code>threshold = capacity * loadFactor</code>）。<br>• **<code>int modCount</code>**：记录 HashMap 结构修改的次数，用于实现快速失败（fail-fast）机制。</p>
<hr>
<h3 id="3-核心方法"><a href="#3-核心方法" class="headerlink" title="3. 核心方法"></a><strong>3. 核心方法</strong></h3><h4 id="3-1-put-K-key-V-value"><a href="#3-1-put-K-key-V-value" class="headerlink" title="3.1 put(K key, V value)"></a><strong>3.1 <code>put(K key, V value)</code></strong></h4><ol>
<li>计算键的哈希值：<code>hash(key)</code>。</li>
<li>根据哈希值计算桶的位置：<code>index = (n - 1) &amp; hash</code>，其中 <code>n</code> 是数组的长度。</li>
<li>如果桶为空，直接插入键值对。</li>
<li>如果桶不为空，遍历链表或红黑树：<br>• 如果找到相同的键，更新值。<br>• 如果未找到相同的键，将键值对插入链表或红黑树。</li>
<li>如果链表长度超过阈值（默认是 8），将链表转换为红黑树。</li>
<li>如果 <code>size</code> 超过 <code>threshold</code>，进行扩容。</li>
</ol>
<h4 id="3-2-get-Object-key"><a href="#3-2-get-Object-key" class="headerlink" title="3.2 get(Object key)"></a><strong>3.2 <code>get(Object key)</code></strong></h4><ol>
<li>计算键的哈希值：<code>hash(key)</code>。</li>
<li>根据哈希值计算桶的位置：<code>index = (n - 1) &amp; hash</code>。</li>
<li>如果桶为空，返回 <code>null</code>。</li>
<li>如果桶不为空，遍历链表或红黑树：<br>• 如果找到相同的键，返回对应的值。<br>• 如果未找到相同的键，返回 <code>null</code>。</li>
</ol>
<h4 id="3-3-resize"><a href="#3-3-resize" class="headerlink" title="3.3 resize()"></a><strong>3.3 <code>resize()</code></strong></h4><ol>
<li>创建一个新的数组，长度为原数组的两倍。</li>
<li>将原数组中的键值对重新分配到新数组中。</li>
<li>更新 <code>table</code> 和 <code>threshold</code>。</li>
</ol>
<hr>
<h3 id="4-哈希冲突解决"><a href="#4-哈希冲突解决" class="headerlink" title="4. 哈希冲突解决"></a><strong>4. 哈希冲突解决</strong></h3><p>当两个键的哈希值映射到同一个桶时，会发生哈希冲突。HashMap 通过以下方式解决哈希冲突：</p>
<ol>
<li><strong>链表法</strong>：冲突的键值对以链表的形式存储在同一个桶中。</li>
<li><strong>红黑树法</strong>：当链表长度超过阈值（默认是 8），链表会转换为红黑树，以提高查找效率。</li>
</ol>
<hr>
<h3 id="5-性能"><a href="#5-性能" class="headerlink" title="5. 性能"></a><strong>5. 性能</strong></h3><p>• <strong>时间复杂度</strong>：<br>  • 插入、删除、查找的平均时间复杂度为 (O(1))。<br>  • 最坏情况下（所有键都映射到同一个桶），时间复杂度为 (O(\log n))（红黑树）或 (O(n))（链表）。<br>• <strong>空间复杂度</strong>：(O(n))。</p>
<hr>
<h3 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Bob&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        map.put(<span class="string">&quot;Charlie&quot;</span>, <span class="number">28</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="string">&quot;Bob&quot;</span>)); <span class="comment">// 输出: 30</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>• HashMap 的底层实现基于数组 + 链表 + 红黑树，具有高效的插入、删除和查找操作。<br>• 通过哈希函数将键映射到桶中，解决哈希冲突的方式包括链表法和红黑树法。<br>• 默认负载因子为 0.75，当键值对数量超过阈值时，HashMap 会进行扩容。<br>• 平均时间复杂度为 (O(1))，最坏情况下为 (O(\log n)) 或 (O(n))。</p>
<h1 id="红黑树了解吗"><a href="#红黑树了解吗" class="headerlink" title="红黑树了解吗"></a>红黑树了解吗</h1><p><strong>红黑树（Red-Black Tree）</strong> 是一种自平衡的二叉查找树（BST），它通过特定的规则确保树的高度保持平衡，从而保证查找、插入和删除操作的时间复杂度为 (O(\log n))。红黑树广泛应用于 Java 的 <code>TreeMap</code> 和 <code>HashMap</code>（JDK 1.8 后用于解决哈希冲突）等数据结构中。</p>
<hr>
<h3 id="1-红黑树的性质"><a href="#1-红黑树的性质" class="headerlink" title="1. 红黑树的性质"></a><strong>1. 红黑树的性质</strong></h3><p>红黑树必须满足以下 5 条性质：</p>
<ol>
<li><strong>节点是红色或黑色</strong>。</li>
<li><strong>根节点是黑色</strong>。</li>
<li><strong>所有叶子节点（NIL 节点）是黑色</strong>。</li>
<li><strong>如果一个节点是红色，则它的两个子节点都是黑色</strong>（即不存在两个连续的红色节点）。</li>
<li><strong>从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点</strong>（即黑高相同）。</li>
</ol>
<hr>
<h3 id="2-红黑树的操作"><a href="#2-红黑树的操作" class="headerlink" title="2. 红黑树的操作"></a><strong>2. 红黑树的操作</strong></h3><h4 id="2-1-插入"><a href="#2-1-插入" class="headerlink" title="2.1 插入"></a><strong>2.1 插入</strong></h4><p>插入新节点时，可能会破坏红黑树的性质，需要通过以下步骤恢复平衡：</p>
<ol>
<li>将新节点插入到红黑树中，并将其颜色设为红色。</li>
<li>如果新节点是根节点，将其颜色设为黑色。</li>
<li>如果新节点的父节点是黑色，无需调整。</li>
<li>如果新节点的父节点是红色，根据叔节点的颜色进行调整：<br>• <strong>叔节点为红色</strong>：将父节点和叔节点设为黑色，祖父节点设为红色，然后以祖父节点为当前节点继续调整。<br>• <strong>叔节点为黑色</strong>：通过旋转（左旋或右旋）和重新着色恢复平衡。</li>
</ol>
<h4 id="2-2-删除"><a href="#2-2-删除" class="headerlink" title="2.2 删除"></a><strong>2.2 删除</strong></h4><p>删除节点时，可能会破坏红黑树的性质，需要通过以下步骤恢复平衡：</p>
<ol>
<li>如果删除的节点是红色，直接删除，无需调整。</li>
<li>如果删除的节点是黑色，根据兄弟节点的颜色和子节点的情况进行调整：<br>• <strong>兄弟节点为红色</strong>：通过旋转和重新着色将兄弟节点设为黑色。<br>• <strong>兄弟节点为黑色</strong>：根据兄弟节点的子节点颜色进行调整，可能需要进行旋转和重新着色。</li>
</ol>
<h4 id="2-3-查找"><a href="#2-3-查找" class="headerlink" title="2.3 查找"></a><strong>2.3 查找</strong></h4><p>红黑树的查找操作与普通二叉查找树相同，时间复杂度为 (O(\log n))。</p>
<hr>
<h3 id="3-红黑树的优势"><a href="#3-红黑树的优势" class="headerlink" title="3. 红黑树的优势"></a><strong>3. 红黑树的优势</strong></h3><p>• <strong>平衡性</strong>：通过红黑树的性质和调整操作，确保树的高度保持平衡。<br>• <strong>高效性</strong>：查找、插入和删除操作的时间复杂度均为 (O(\log n))。<br>• <strong>适用性</strong>：广泛应用于需要高效查找和动态更新的场景，如 Java 的 <code>TreeMap</code> 和 <code>HashMap</code>。</p>
<hr>
<h3 id="4-红黑树与-AVL-树的对比"><a href="#4-红黑树与-AVL-树的对比" class="headerlink" title="4. 红黑树与 AVL 树的对比"></a><strong>4. 红黑树与 AVL 树的对比</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>红黑树</th>
<th>AVL 树</th>
</tr>
</thead>
<tbody><tr>
<td><strong>平衡性</strong></td>
<td>相对宽松，允许一定的失衡</td>
<td>严格平衡，左右子树高度差不超过 1</td>
</tr>
<tr>
<td><strong>插入&#x2F;删除性能</strong></td>
<td>调整次数较少，性能较高</td>
<td>调整次数较多，性能较低</td>
</tr>
<tr>
<td><strong>查找性能</strong></td>
<td>由于平衡性相对宽松，查找性能略低</td>
<td>由于严格平衡，查找性能较高</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>适合频繁插入和删除的场景</td>
<td>适合查找频繁的场景</td>
</tr>
</tbody></table>
<hr>
<h3 id="5-红黑树在-Java-中的应用"><a href="#5-红黑树在-Java-中的应用" class="headerlink" title="5. 红黑树在 Java 中的应用"></a><strong>5. 红黑树在 Java 中的应用</strong></h3><p>• **<code>TreeMap</code>**：基于红黑树实现的有序键值对集合。<br>• **<code>HashMap</code>**：JDK 1.8 后，当哈希冲突导致链表长度超过阈值（默认是 8）时，链表会转换为红黑树，以提高查找效率。</p>
<hr>
<h3 id="6-示例-1"><a href="#6-示例-1" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h3><p>以下是一个简单的红黑树插入操作的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedBlackTreeExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        TreeMap&lt;Integer, String&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">10</span>, <span class="string">&quot;Alice&quot;</span>);</span><br><span class="line">        map.put(<span class="number">20</span>, <span class="string">&quot;Bob&quot;</span>);</span><br><span class="line">        map.put(<span class="number">30</span>, <span class="string">&quot;Charlie&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(map.get(<span class="number">20</span>)); <span class="comment">// 输出: Bob</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结-1"><a href="#7-总结-1" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>红黑树是一种高效的自平衡二叉查找树，通过特定的规则和调整操作确保树的高度保持平衡。它的查找、插入和删除操作的时间复杂度均为 (O(\log n))，广泛应用于需要高效查找和动态更新的场景。</p>
<h1 id="HashMap是否线程安全，为何"><a href="#HashMap是否线程安全，为何" class="headerlink" title="HashMap是否线程安全，为何"></a>HashMap是否线程安全，为何</h1><p><strong>HashMap</strong> 不是线程安全的。在多线程环境下，多个线程同时对 HashMap 进行修改操作（如插入、删除、更新）可能会导致数据不一致、死循环或其他不可预知的错误。以下是 HashMap 非线程安全的原因及具体问题：</p>
<hr>
<h3 id="1-数据不一致"><a href="#1-数据不一致" class="headerlink" title="1. 数据不一致"></a><strong>1. 数据不一致</strong></h3><p>在多线程环境下，如果多个线程同时修改 HashMap，可能会导致数据丢失或覆盖。例如：<br>• 线程 A 和线程 B 同时插入不同的键值对，但它们的哈希值映射到同一个桶。<br>• 由于没有同步机制，线程 A 和线程 B 可能会互相覆盖对方的数据，导致数据丢失。</p>
<hr>
<h3 id="2-死循环"><a href="#2-死循环" class="headerlink" title="2. 死循环"></a><strong>2. 死循环</strong></h3><p>在 JDK 1.7 及之前的版本中，HashMap 的扩容操作（<code>resize()</code>）可能会导致死循环。具体原因如下：<br>• 在扩容时，HashMap 会将原数组中的链表重新分配到新数组中。<br>• 如果多个线程同时进行扩容操作，可能会导致链表形成环形结构，从而导致死循环。</p>
<hr>
<h3 id="3-结构修改异常"><a href="#3-结构修改异常" class="headerlink" title="3. 结构修改异常"></a><strong>3. 结构修改异常</strong></h3><p>HashMap 通过 <code>modCount</code> 记录结构修改的次数，用于实现快速失败（fail-fast）机制。在多线程环境下，如果一个线程在遍历 HashMap，而另一个线程修改了 HashMap 的结构（如插入或删除键值对），可能会导致 <code>ConcurrentModificationException</code> 异常。</p>
<hr>
<h3 id="4-为什么-HashMap-不是线程安全的？"><a href="#4-为什么-HashMap-不是线程安全的？" class="headerlink" title="4. 为什么 HashMap 不是线程安全的？"></a><strong>4. 为什么 HashMap 不是线程安全的？</strong></h3><p>HashMap 的设计目标是高效的单线程操作，因此没有内置同步机制。为了提高性能，HashMap 在实现中省略了锁和其他同步机制，这使得它在多线程环境下无法保证线程安全。</p>
<hr>
<h3 id="5-如何实现线程安全的-HashMap？"><a href="#5-如何实现线程安全的-HashMap？" class="headerlink" title="5. 如何实现线程安全的 HashMap？"></a><strong>5. 如何实现线程安全的 HashMap？</strong></h3><p>如果需要线程安全的 HashMap，可以使用以下替代方案：</p>
<ol>
<li><p>**<code>Collections.synchronizedMap(new HashMap&lt;&gt;())</code>**：<br>• 通过 <code>Collections.synchronizedMap()</code> 方法将 HashMap 包装为线程安全的 Map。<br>• 示例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = Collections.synchronizedMap(<span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>• <strong>缺点</strong>：性能较低，因为所有操作都需要加锁。</p>
</li>
<li><p>**<code>ConcurrentHashMap</code>**：<br>• <code>ConcurrentHashMap</code> 是专门为多线程环境设计的线程安全 HashMap。<br>• 通过分段锁（JDK 1.7）或 CAS 操作（JDK 1.8）实现高效的并发访问。<br>• 示例：</p>
  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">ConcurrentHashMap</span>&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>• <strong>优点</strong>：性能高，支持高并发访问。</p>
</li>
</ol>
<hr>
<h3 id="6-示例-2"><a href="#6-示例-2" class="headerlink" title="6. 示例"></a><strong>6. 示例</strong></h3><p>以下是一个 HashMap 非线程安全的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HashMapExample</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">                map.put(<span class="string">&quot;key&quot;</span> + i, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;Map size: &quot;</span> + map.size()); <span class="comment">// 结果可能小于 2000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="7-总结-2"><a href="#7-总结-2" class="headerlink" title="7. 总结"></a><strong>7. 总结</strong></h3><p>• HashMap 不是线程安全的，多线程环境下可能会导致数据不一致、死循环或其他问题。<br>• 如果需要线程安全的 HashMap，可以使用 <code>Collections.synchronizedMap()</code> 或 <code>ConcurrentHashMap</code>。<br>• <code>ConcurrentHashMap</code> 是推荐的线程安全 HashMap 实现，具有高效的并发访问性能。</p>
<h1 id="Java的内存管理有哪几种方式"><a href="#Java的内存管理有哪几种方式" class="headerlink" title="Java的内存管理有哪几种方式"></a>Java的内存管理有哪几种方式</h1><p>在Java中，内存管理主要通过以下几种方式来实现：</p>
<h3 id="1-自动内存管理（垃圾回收机制）"><a href="#1-自动内存管理（垃圾回收机制）" class="headerlink" title="1. 自动内存管理（垃圾回收机制）"></a>1. <strong>自动内存管理（垃圾回收机制）</strong></h3><p>   • <strong>垃圾回收（Garbage Collection, GC）</strong>：Java虚拟机（JVM）通过垃圾回收机制自动管理内存。垃圾回收器会定期检查不再被引用的对象，并释放它们占用的内存。开发者不需要手动释放内存，这减少了内存泄漏和悬空指针的风险。<br>   • <strong>垃圾回收算法</strong>：Java中的垃圾回收器使用不同的算法来管理内存，如标记-清除（Mark-Sweep）、标记-整理（Mark-Compact）、复制算法（Copying）、分代收集（Generational Collection）等。</p>
<h3 id="2-堆内存管理"><a href="#2-堆内存管理" class="headerlink" title="2. 堆内存管理"></a>2. <strong>堆内存管理</strong></h3><p>   • <strong>堆（Heap）</strong>：Java中的对象实例和数组都存储在堆内存中。堆内存是JVM管理的最大一块内存区域，所有线程共享。堆内存的大小可以通过JVM参数进行配置（如 <code>-Xmx</code> 和 <code>-Xms</code>）。<br>   • <strong>堆内存分区</strong>：堆内存通常分为新生代（Young Generation）和老年代（Old Generation），新生代又分为Eden区、Survivor区（From和To）。不同的区域使用不同的垃圾回收策略。</p>
<h3 id="3-栈内存管理"><a href="#3-栈内存管理" class="headerlink" title="3. 栈内存管理"></a>3. <strong>栈内存管理</strong></h3><p>   • <strong>栈（Stack）</strong>：每个线程都有自己的栈内存，用于存储局部变量、方法调用和部分对象引用。栈内存的大小是固定的，可以通过JVM参数（如 <code>-Xss</code>）进行配置。<br>   • <strong>栈帧（Stack Frame）</strong>：每个方法调用都会在栈中创建一个栈帧，栈帧中存储方法的局部变量、操作数栈、动态链接和方法返回地址等信息。</p>
<h3 id="4-方法区（元空间）"><a href="#4-方法区（元空间）" class="headerlink" title="4. 方法区（元空间）"></a>4. <strong>方法区（元空间）</strong></h3><p>   • <strong>方法区（Method Area）</strong>：方法区用于存储类的元数据、常量池、静态变量等信息。在Java 8之前，方法区是堆的一部分，称为永久代（PermGen）。从Java 8开始，方法区被替换为元空间（Metaspace），元空间使用本地内存（Native Memory）来存储类元数据，避免了永久代的内存溢出问题。</p>
<h3 id="5-本地方法栈"><a href="#5-本地方法栈" class="headerlink" title="5. 本地方法栈"></a>5. <strong>本地方法栈</strong></h3><p>   • <strong>本地方法栈（Native Method Stack）</strong>：用于支持本地方法（Native Method）的执行。本地方法是用其他语言（如C&#x2F;C++）编写的方法，本地方法栈与Java栈类似，但专门用于本地方法的调用。</p>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. <strong>直接内存</strong></h3><p>   • <strong>直接内存（Direct Memory）</strong>：直接内存是JVM外部的内存区域，通常通过 <code>java.nio</code> 包中的 <code>ByteBuffer</code> 类来分配和管理。直接内存不受JVM垃圾回收机制的管理，但可以通过 <code>System.gc()</code> 或 <code>ByteBuffer</code> 的 <code>cleaner</code> 机制来释放。</p>
<h3 id="7-内存分配策略"><a href="#7-内存分配策略" class="headerlink" title="7. 内存分配策略"></a>7. <strong>内存分配策略</strong></h3><p>   • <strong>对象分配</strong>：对象通常在新生代的Eden区分配，如果对象存活时间较长，会被移动到Survivor区，最终进入老年代。<br>   • <strong>大对象分配</strong>：大对象（如大数组）可能会直接分配到老年代，以避免在新生代频繁复制。</p>
<h3 id="8-内存泄漏处理"><a href="#8-内存泄漏处理" class="headerlink" title="8. 内存泄漏处理"></a>8. <strong>内存泄漏处理</strong></h3><p>   • <strong>内存泄漏</strong>：虽然Java有垃圾回收机制，但内存泄漏仍然可能发生，例如由于静态集合类持有对象引用、未关闭的资源（如数据库连接、文件流）等。开发者需要注意及时释放资源，避免内存泄漏。</p>
<h3 id="9-JVM参数调优"><a href="#9-JVM参数调优" class="headerlink" title="9. JVM参数调优"></a>9. <strong>JVM参数调优</strong></h3><p>   • <strong>JVM参数</strong>：通过调整JVM参数，可以优化内存管理。常见的参数包括：<br>     ◦ <code>-Xmx</code>：设置最大堆内存。<br>     ◦ <code>-Xms</code>：设置初始堆内存。<br>     ◦ <code>-Xss</code>：设置线程栈大小。<br>     ◦ <code>-XX:MaxMetaspaceSize</code>：设置最大元空间大小。<br>     ◦ <code>-XX:NewRatio</code>：设置新生代与老年代的比例。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Java的内存管理主要通过自动垃圾回收机制来实现，开发者不需要手动管理内存。JVM将内存划分为不同的区域（如堆、栈、方法区等），每个区域有不同的管理策略。通过合理配置JVM参数和使用正确的编程实践，可以优化内存使用，避免内存泄漏和性能问题。</p>
<h1 id="垃圾回收算法了解吗"><a href="#垃圾回收算法了解吗" class="headerlink" title="垃圾回收算法了解吗"></a>垃圾回收算法了解吗</h1><p>是的，Java中的垃圾回收（GC）算法是JVM自动管理内存的核心机制。以下是常见的垃圾回收算法及其特点，适合面试时简洁明了地回答：</p>
<hr>
<h3 id="1-标记-清除算法（Mark-Sweep）"><a href="#1-标记-清除算法（Mark-Sweep）" class="headerlink" title="1. 标记-清除算法（Mark-Sweep）"></a>1. <strong>标记-清除算法（Mark-Sweep）</strong></h3><p>   • <strong>过程</strong>：<br>     1. 标记：遍历所有对象，标记存活的对象。<br>     2. 清除：回收未被标记的对象。<br>   • <strong>优点</strong>：简单，适用于老年代。<br>   • <strong>缺点</strong>：产生内存碎片，效率较低。</p>
<hr>
<h3 id="2-标记-整理算法（Mark-Compact）"><a href="#2-标记-整理算法（Mark-Compact）" class="headerlink" title="2. 标记-整理算法（Mark-Compact）"></a>2. <strong>标记-整理算法（Mark-Compact）</strong></h3><p>   • <strong>过程</strong>：<br>     1. 标记：标记存活的对象。<br>     2. 整理：将存活对象向一端移动，清理边界外的内存。<br>   • <strong>优点</strong>：避免内存碎片。<br>   • <strong>缺点</strong>：整理过程耗时，适用于老年代。</p>
<hr>
<h3 id="3-复制算法（Copying）"><a href="#3-复制算法（Copying）" class="headerlink" title="3. 复制算法（Copying）"></a>3. <strong>复制算法（Copying）</strong></h3><p>   • <strong>过程</strong>：<br>     1. 将内存分为两块（From和To）。<br>     2. 将From区存活对象复制到To区，清理From区。<br>   • <strong>优点</strong>：高效，无内存碎片。<br>   • <strong>缺点</strong>：内存利用率低（只有一半可用），适用于新生代。</p>
<hr>
<h3 id="4-分代收集算法（Generational-Collection）"><a href="#4-分代收集算法（Generational-Collection）" class="headerlink" title="4. 分代收集算法（Generational Collection）"></a>4. <strong>分代收集算法（Generational Collection）</strong></h3><p>   • <strong>思想</strong>：根据对象生命周期将堆分为新生代和老年代。<br>     ◦ <strong>新生代</strong>：使用复制算法（如Eden区和Survivor区）。<br>     ◦ <strong>老年代</strong>：使用标记-清除或标记-整理算法。<br>   • <strong>优点</strong>：针对不同区域优化，提高效率。<br>   • <strong>缺点</strong>：实现复杂。</p>
<hr>
<h3 id="5-增量收集算法（Incremental-GC）"><a href="#5-增量收集算法（Incremental-GC）" class="headerlink" title="5. 增量收集算法（Incremental GC）"></a>5. <strong>增量收集算法（Incremental GC）</strong></h3><p>   • <strong>思想</strong>：将GC过程分为多个小步骤，减少停顿时间。<br>   • <strong>优点</strong>：减少应用程序停顿。<br>   • <strong>缺点</strong>：总体效率较低。</p>
<hr>
<h3 id="6-G1垃圾回收器（Garbage-First）"><a href="#6-G1垃圾回收器（Garbage-First）" class="headerlink" title="6. G1垃圾回收器（Garbage-First）"></a>6. <strong>G1垃圾回收器（Garbage-First）</strong></h3><p>   • <strong>特点</strong>：<br>     ◦ 将堆划分为多个区域（Region），动态选择回收价值最高的区域。<br>     ◦ 结合标记-整理和复制算法。<br>   • <strong>优点</strong>：低停顿时间，适合大内存应用。<br>   • <strong>缺点</strong>：实现复杂。</p>
<hr>
<h3 id="面试回答示例："><a href="#面试回答示例：" class="headerlink" title="面试回答示例："></a>面试回答示例：</h3><p>“Java的垃圾回收算法主要有标记-清除、标记-整理、复制算法和分代收集。标记-清除简单但会产生内存碎片，标记-整理避免了碎片但耗时，复制算法高效但内存利用率低。分代收集根据对象生命周期将堆分为新生代和老年代，分别采用不同的算法优化效率。此外，G1回收器通过分区管理和动态选择回收区域，实现了低停顿时间，适合大内存应用。” </p>
<hr>
<h1 id="TCP协议三次握手，四次挥手分别讲解，并且说说为什么是4次挥手不是三次"><a href="#TCP协议三次握手，四次挥手分别讲解，并且说说为什么是4次挥手不是三次" class="headerlink" title="TCP协议三次握手，四次挥手分别讲解，并且说说为什么是4次挥手不是三次"></a>TCP协议三次握手，四次挥手分别讲解，并且说说为什么是4次挥手不是三次</h1><h3 id="TCP协议的三次握手与四次挥手"><a href="#TCP协议的三次握手与四次挥手" class="headerlink" title="TCP协议的三次握手与四次挥手"></a><strong>TCP协议的三次握手与四次挥手</strong></h3><hr>
<h3 id="1-三次握手（建立连接）"><a href="#1-三次握手（建立连接）" class="headerlink" title="1. 三次握手（建立连接）"></a><strong>1. 三次握手（建立连接）</strong></h3><p>三次握手是TCP协议建立连接的过程，确保双方都能正常发送和接收数据。</p>
<p><strong>过程</strong>：</p>
<ol>
<li><strong>第一次握手</strong>：客户端发送<code>SYN=1</code>（同步标志）和初始序列号<code>seq=x</code>给服务器，表示请求建立连接。</li>
<li><strong>第二次握手</strong>：服务器收到<code>SYN</code>后，回复<code>SYN=1</code>、<code>ACK=1</code>（确认标志）、确认号<code>ack=x+1</code>和初始序列号<code>seq=y</code>，表示同意建立连接。</li>
<li><strong>第三次握手</strong>：客户端收到服务器的<code>SYN+ACK</code>后，发送<code>ACK=1</code>、确认号<code>ack=y+1</code>和序列号<code>seq=x+1</code>，表示确认连接。</li>
</ol>
<p><strong>目的</strong>：<br>• 确保双方都能正常发送和接收数据。<br>• 防止旧的重复连接请求导致错误。</p>
<hr>
<h3 id="2-四次挥手（断开连接）"><a href="#2-四次挥手（断开连接）" class="headerlink" title="2. 四次挥手（断开连接）"></a><strong>2. 四次挥手（断开连接）</strong></h3><p>四次挥手是TCP协议断开连接的过程，确保双方都能安全关闭连接。</p>
<p><strong>过程</strong>：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送<code>FIN=1</code>（结束标志）和序列号<code>seq=u</code>给服务器，表示请求关闭连接。</li>
<li><strong>第二次挥手</strong>：服务器收到<code>FIN</code>后，回复<code>ACK=1</code>、确认号<code>ack=u+1</code>和序列号<code>seq=v</code>，表示确认关闭请求。</li>
<li><strong>第三次挥手</strong>：服务器发送<code>FIN=1</code>和序列号<code>seq=w</code>给客户端，表示服务器也准备关闭连接。</li>
<li><strong>第四次挥手</strong>：客户端收到<code>FIN</code>后，回复<code>ACK=1</code>、确认号<code>ack=w+1</code>和序列号<code>seq=u+1</code>，表示确认关闭。</li>
</ol>
<p><strong>目的</strong>：<br>• 确保双方都完成数据传输并安全关闭连接。<br>• 防止数据丢失或连接异常。</p>
<hr>
<h3 id="为什么是四次挥手，而不是三次？"><a href="#为什么是四次挥手，而不是三次？" class="headerlink" title="为什么是四次挥手，而不是三次？"></a><strong>为什么是四次挥手，而不是三次？</strong></h3><p>四次挥手的原因是TCP连接是<strong>全双工</strong>的，即数据可以双向传输。关闭连接时，需要双方都确认关闭：</p>
<ol>
<li>客户端发送<code>FIN</code>，表示不再发送数据，但还可以接收数据。</li>
<li>服务器收到<code>FIN</code>后，先回复<code>ACK</code>，表示确认客户端的关闭请求，但服务器可能还有数据要发送。</li>
<li>服务器发送<code>FIN</code>，表示服务器也不再发送数据。</li>
<li>客户端收到<code>FIN</code>后，回复<code>ACK</code>，确认关闭。</li>
</ol>
<p><strong>为什么不能合并为三次？</strong><br>如果服务器在收到客户端的<code>FIN</code>后，立即发送<code>FIN+ACK</code>，可能会出现以下问题：<br>• 服务器可能还有未发送完的数据，需要等待数据传输完成后再关闭。<br>• 合并<code>FIN+ACK</code>会导致客户端误以为服务器已经关闭，而实际上服务器仍在发送数据。</p>
<p>因此，四次挥手是确保双方都能安全关闭连接的必要步骤。</p>
<hr>
<h3 id="面试回答示例：-1"><a href="#面试回答示例：-1" class="headerlink" title="面试回答示例："></a><strong>面试回答示例：</strong></h3><p>“TCP的三次握手用于建立连接，客户端发送<code>SYN</code>，服务器回复<code>SYN+ACK</code>，客户端再发送<code>ACK</code>，确保双方都能正常通信。四次挥手用于断开连接，客户端发送<code>FIN</code>，服务器回复<code>ACK</code>，服务器再发送<code>FIN</code>，客户端回复<code>ACK</code>，确保双方都安全关闭。四次挥手的原因是TCP连接是全双工的，双方需要分别确认关闭，不能合并为三次，否则可能导致数据丢失或连接异常。”</p>
<hr>
<h3 id="通俗易懂的解释："><a href="#通俗易懂的解释：" class="headerlink" title="通俗易懂的解释："></a><strong>通俗易懂的解释：</strong></h3><hr>
<h3 id="1-同步标志（SYN）"><a href="#1-同步标志（SYN）" class="headerlink" title="1. 同步标志（SYN）"></a><strong>1. 同步标志（SYN）</strong></h3><p>• <strong>作用</strong>：用来发起连接请求，表示“我想和你建立连接”。<br>• <strong>通俗理解</strong>：就像你打电话给对方，说“喂，我们开始聊天吧！”。</p>
<hr>
<h3 id="2-序列号（seq）"><a href="#2-序列号（seq）" class="headerlink" title="2. 序列号（seq）"></a><strong>2. 序列号（seq）</strong></h3><p>• <strong>作用</strong>：用来标识发送的数据包的顺序，确保数据按正确顺序接收。<br>• <strong>通俗理解</strong>：就像你给对方发消息时，给每条消息编号（比如第1条、第2条），这样对方就知道先读哪条。</p>
<hr>
<h3 id="3-确认标志（ACK）"><a href="#3-确认标志（ACK）" class="headerlink" title="3. 确认标志（ACK）"></a><strong>3. 确认标志（ACK）</strong></h3><p>• <strong>作用</strong>：用来确认收到了对方的数据，表示“我收到了你的消息”。<br>• <strong>通俗理解</strong>：就像你收到对方的短信后，回复“收到！”。</p>
<hr>
<h3 id="4-确认号（ack）"><a href="#4-确认号（ack）" class="headerlink" title="4. 确认号（ack）"></a><strong>4. 确认号（ack）</strong></h3><p>• <strong>作用</strong>：用来告诉对方“我期待收到下一条消息的编号”。<br>• <strong>通俗理解</strong>：比如你收到对方的第1条消息后，回复“我收到了第1条，请发第2条”。</p>
<hr>
<h3 id="举例说明（三次握手）："><a href="#举例说明（三次握手）：" class="headerlink" title="举例说明（三次握手）："></a><strong>举例说明（三次握手）：</strong></h3><ol>
<li><p><strong>第一次握手</strong>：<br>• 客户端发送<code>SYN=1</code>和<code>seq=x</code>，表示“我想和你建立连接，这是第x条消息”。<br>• 就像你说：“喂，我们开始聊天吧！（第1条）”。</p>
</li>
<li><p><strong>第二次握手</strong>：<br>• 服务器回复<code>SYN=1</code>、<code>ACK=1</code>、<code>seq=y</code>和<code>ack=x+1</code>，表示“我同意和你聊天，这是第y条消息，我收到了你的第1条，请发第2条”。<br>• 就像对方回复：“好啊！（第1条），我收到了你的第1条，请发第2条”。</p>
</li>
<li><p><strong>第三次握手</strong>：<br>• 客户端发送<code>ACK=1</code>、<code>seq=x+1</code>和<code>ack=y+1</code>，表示“我收到了你的第1条，请发第2条”。<br>• 就像你回复：“收到！（第2条），我收到了你的第1条，请发第2条”。</p>
</li>
</ol>
<hr>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h3><p>• <strong>SYN</strong>：发起连接请求。<br>• <strong>seq</strong>：给消息编号，确保顺序。<br>• <strong>ACK</strong>：确认收到消息。<br>• <strong>ack</strong>：告诉对方接下来期待收到哪条消息。</p>
<hr>
<h3 id="面试回答示例：-2"><a href="#面试回答示例：-2" class="headerlink" title="面试回答示例："></a><strong>面试回答示例：</strong></h3><p>“SYN是同步标志，用来发起连接请求；seq是序列号，用来标识数据包的顺序；ACK是确认标志，表示收到了对方的数据；ack是确认号，告诉对方接下来期待收到哪条消息。这些机制共同确保了TCP连接的可靠性和顺序性。”</p>
<hr>
<p>这样解释，既通俗易懂，又能让面试官快速理解核心概念！</p>
<h1 id="TCP如何保证传输安全"><a href="#TCP如何保证传输安全" class="headerlink" title="TCP如何保证传输安全"></a>TCP如何保证传输安全</h1><h3 id="3-超时重传（Retransmission）"><a href="#3-超时重传（Retransmission）" class="headerlink" title="3. 超时重传（Retransmission）"></a><strong>3. 超时重传（Retransmission）</strong></h3><h4 id="作用与实现原理"><a href="#作用与实现原理" class="headerlink" title="作用与实现原理"></a><strong>作用与实现原理</strong></h4><p>• <strong>触发条件</strong>：<br>  发送方发送一个数据包后，会启动一个<strong>超时计时器（RTO, Retransmission Timeout）</strong>。如果在RTO时间内未收到接收方的确认（ACK），则认为数据包丢失，触发重传。<br>  • <strong>RTO计算</strong>：RTO基于网络往返时间（RTT）动态调整，通过历史RTT的加权平均值估算。  </p>
<p>• <strong>重传过程</strong>：  </p>
<ol>
<li>发送方发送数据包（如<code>seq=100</code>）。  </li>
<li>接收方未返回ACK（如<code>ack=101</code>），可能是数据包丢失或ACK丢失。  </li>
<li>发送方超时后，重新发送相同数据包。</li>
</ol>
<p>• <strong>意义</strong>：<br>  确保即使数据包丢失或ACK丢失，数据仍能可靠到达接收方。  </p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>假设发送方发送数据包1，但未收到ACK：  </p>
<ol>
<li>发送方等待RTO时间（例如500ms）。  </li>
<li>超时后，重传数据包1。  </li>
<li>若收到ACK，继续发送后续数据；若仍超时，再次重传（RTO可能翻倍，避免频繁重传加剧网络拥塞）。</li>
</ol>
<hr>
<h3 id="4-流量控制（Flow-Control）"><a href="#4-流量控制（Flow-Control）" class="headerlink" title="4. 流量控制（Flow Control）"></a><strong>4. 流量控制（Flow Control）</strong></h3><h4 id="作用与实现原理-1"><a href="#作用与实现原理-1" class="headerlink" title="作用与实现原理"></a><strong>作用与实现原理</strong></h4><p>• <strong>滑动窗口机制</strong>：<br>  接收方通过<strong>接收窗口（rwnd, Receive Window）</strong>告知发送方自己剩余的缓冲区大小。发送方根据窗口大小调整发送速率。<br>  • <strong>窗口更新</strong>：接收方每次发送ACK时携带当前窗口大小（如<code>ACK=200, rwnd=3000</code>）。  </p>
<p>• <strong>过程</strong>：  </p>
<ol>
<li>接收方缓冲区剩余3000字节，发送ACK时附带<code>rwnd=3000</code>。  </li>
<li>发送方最多发送3000字节的数据。  </li>
<li>接收方处理完数据后，缓冲区释放，发送新的<code>rwnd</code>值（如<code>rwnd=5000</code>）。</li>
</ol>
<p>• <strong>零窗口处理</strong>：<br>  若接收方缓冲区已满（<code>rwnd=0</code>），发送方暂停发送，并周期性发送<strong>窗口探测包</strong>（携带1字节数据），直到接收方通知窗口恢复。  </p>
<p>• <strong>意义</strong>：<br>  防止发送方发送速度超过接收方的处理能力，避免数据被丢弃或缓冲区溢出。  </p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a><strong>示例</strong></h4><p>接收方缓冲区容量为5000字节：  </p>
<ol>
<li>发送方发送3000字节后，接收方回复<code>ACK=3001, rwnd=2000</code>（剩余2000字节）。  </li>
<li>发送方最多再发送2000字节。  </li>
<li>接收方处理完2000字节后，回复<code>ACK=5001, rwnd=5000</code>，发送方恢复发送。</li>
</ol>
<hr>
<h3 id="5-拥塞控制（Congestion-Control）"><a href="#5-拥塞控制（Congestion-Control）" class="headerlink" title="5. 拥塞控制（Congestion Control）"></a><strong>5. 拥塞控制（Congestion Control）</strong></h3><h4 id="作用与实现原理-2"><a href="#作用与实现原理-2" class="headerlink" title="作用与实现原理"></a><strong>作用与实现原理</strong></h4><p>通过动态调整发送速率，避免网络因过量数据包而拥塞。核心算法包括：  </p>
<p>• <strong>慢启动（Slow Start）</strong>：<br>  • <strong>初始阶段</strong>：拥塞窗口（cwnd, Congestion Window）从1 MSS（最大报文段大小）开始，每收到一个ACK，cwnd指数增长（如1 → 2 → 4 → 8）。<br>  • <strong>目的</strong>：快速探测网络可用带宽。  </p>
<p>• <strong>拥塞避免（Congestion Avoidance）</strong>：<br>  • <strong>触发条件</strong>：当cwnd达到慢启动阈值（ssthresh）时，进入线性增长阶段（每RTT增加1 MSS）。<br>  • <strong>目的</strong>：避免激进增长导致网络拥塞。  </p>
<p>• <strong>快速重传与快速恢复（Fast Retransmit &amp; Recovery）</strong>：<br>  • <strong>触发条件</strong>：发送方连续收到3个重复ACK（如<code>ACK=100</code>重复3次），认为数据包丢失，但网络仍有容量。<br>  • <strong>过程</strong>：<br>    1. 立即重传丢失的数据包。<br>    2. 将ssthresh设为当前cwnd的一半，cwnd设为<code>ssthresh + 3</code>（补偿已确认的3个重复ACK）。<br>    3. 进入拥塞避免阶段，线性增长cwnd。  </p>
<p>• <strong>意义</strong>：<br>  通过动态调整发送速率，平衡网络负载，避免全局性拥塞崩溃。  </p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a><strong>示例</strong></h4><ol>
<li><p><strong>慢启动阶段</strong>：<br>• cwnd&#x3D;1，发送1个数据包。<br>• 收到ACK后，cwnd&#x3D;2，发送2个数据包。<br>• 持续指数增长直到cwnd达到ssthresh（如16）。  </p>
</li>
<li><p><strong>拥塞避免阶段</strong>：<br>• cwnd&#x3D;16，每RTT增加1 MSS，变为17 → 18 → 19…  </p>
</li>
<li><p><strong>网络拥塞时</strong>：<br>• 若超时未收到ACK，将ssthresh设为当前cwnd的一半（如20→10），cwnd重置为1，重新进入慢启动。<br>• 若收到3个重复ACK，触发快速重传，cwnd调整为<code>ssthresh + 3</code>，进入拥塞避免。</p>
</li>
</ol>
<hr>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>• <strong>超时重传</strong>：通过超时机制确保丢失数据包被重传。<br>• <strong>流量控制</strong>：通过滑动窗口匹配发送速率与接收方处理能力。<br>• <strong>拥塞控制</strong>：通过慢启动、拥塞避免等算法平衡网络负载。  </p>
<p><strong>三者协同作用</strong>：<br>• 流量控制解决<strong>接收方处理能力不足</strong>的问题。<br>• 拥塞控制解决<strong>网络资源竞争</strong>的问题。<br>• 超时重传解决<strong>数据包丢失</strong>的问题。  </p>
<p><strong>面试回答示例</strong>：<br>“TCP通过超时重传、流量控制和拥塞控制保证可靠性。超时重传在数据包丢失时重新发送；流量控制通过滑动窗口限制发送速率，避免接收方溢出；拥塞控制通过慢启动和拥塞避免动态调整速率，防止网络过载。三者协同工作，确保数据高效、可靠传输。”</p>
<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><hr>
<h3 id="核心思路"><a href="#核心思路" class="headerlink" title="核心思路"></a><strong>核心思路</strong></h3><p>• <strong>队列特性</strong>：先进先出（FIFO）。<br>• <strong>栈特性</strong>：后进先出（LIFO）。<br>• <strong>实现方法</strong>：<br>  • 用<strong>栈A</strong>处理入队操作（直接压栈）。<br>  • 用<strong>栈B</strong>处理出队操作，当栈B为空时，将栈A的全部元素弹出并压入栈B，此时栈B的出栈顺序即为队列的出队顺序。</p>
<hr>
<h3 id="Java代码实现"><a href="#Java代码实现" class="headerlink" title="Java代码实现"></a><strong>Java代码实现</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;T&gt; stackIn;  <span class="comment">// 负责入队</span></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;T&gt; stackOut; <span class="comment">// 负责出队</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        stackIn = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        stackOut = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">enqueue</span><span class="params">(T item)</span> &#123;</span><br><span class="line">        stackIn.push(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队操作</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果出队栈为空，将入队栈的所有元素转移过去</span></span><br><span class="line">        <span class="keyword">if</span> (stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 查看队首元素（不删除）</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">peek</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;队列为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stackOut.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!stackIn.isEmpty()) &#123;</span><br><span class="line">                stackOut.push(stackIn.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stackOut.peek();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断队列是否为空</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> stackIn.isEmpty() &amp;&amp; stackOut.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 测试代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        MyQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">MyQueue</span>&lt;&gt;();</span><br><span class="line">        queue.enqueue(<span class="number">1</span>);</span><br><span class="line">        queue.enqueue(<span class="number">2</span>);</span><br><span class="line">        queue.enqueue(<span class="number">3</span>);</span><br><span class="line">        System.out.println(queue.dequeue()); <span class="comment">// 输出 1</span></span><br><span class="line">        queue.enqueue(<span class="number">4</span>);</span><br><span class="line">        System.out.println(queue.dequeue()); <span class="comment">// 输出 2</span></span><br><span class="line">        System.out.println(queue.peek());     <span class="comment">// 输出 3</span></span><br><span class="line">        System.out.println(queue.dequeue()); <span class="comment">// 输出 3</span></span><br><span class="line">        System.out.println(queue.isEmpty());  <span class="comment">// 输出 false</span></span><br><span class="line">        System.out.println(queue.dequeue()); <span class="comment">// 输出 4</span></span><br><span class="line">        System.out.println(queue.isEmpty());  <span class="comment">// 输出 true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="关键逻辑解释"><a href="#关键逻辑解释" class="headerlink" title="关键逻辑解释"></a><strong>关键逻辑解释</strong></h3><ol>
<li><p><strong>入队（<code>enqueue</code>）</strong>：<br>• 直接将元素压入 <code>stackIn</code>，时间复杂度 **O(1)**。</p>
</li>
<li><p><strong>出队（<code>dequeue</code>）</strong>：<br>• 如果 <code>stackOut</code> 为空，将 <code>stackIn</code> 的所有元素弹出并压入 <code>stackOut</code>，此时 <code>stackOut</code> 的栈顶即为队列头部。<br>• 弹出 <code>stackOut</code> 的栈顶元素，**摊还时间复杂度为 O(1)**（每个元素最多被转移两次）。</p>
</li>
<li><p><strong>查看队首（<code>peek</code>）</strong>：<br>• 逻辑与 <code>dequeue</code> 类似，但不删除元素。</p>
</li>
<li><p><strong>判空（<code>isEmpty</code>）</strong>：<br>• 当两个栈均为空时，队列为空。</p>
</li>
</ol>
<hr>
<h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a><strong>时间复杂度分析</strong></h3><table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>入队</td>
<td>O(1)</td>
<td>直接压入栈</td>
</tr>
<tr>
<td>出队</td>
<td>摊还 O(1)</td>
<td>每个元素最多被转移两次</td>
</tr>
<tr>
<td>查看队首</td>
<td>摊还 O(1)</td>
<td>同出队操作</td>
</tr>
<tr>
<td>判空</td>
<td>O(1)</td>
<td>检查两个栈是否均为空</td>
</tr>
</tbody></table>
<hr>
<h3 id="为什么需要两个栈？"><a href="#为什么需要两个栈？" class="headerlink" title="为什么需要两个栈？"></a><strong>为什么需要两个栈？</strong></h3><p>• <strong>栈的逆序特性</strong>：<br>  栈是后进先出的，但通过将元素从 <code>stackIn</code> 转移到 <code>stackOut</code>，可以实现两次逆序（LIFO → FIFO），从而模拟队列的先进先出特性。</p>
<hr>
<h3 id="示例流程"><a href="#示例流程" class="headerlink" title="示例流程"></a><strong>示例流程</strong></h3><ol>
<li><p><strong>初始状态</strong>：<br>• <code>stackIn = []</code>，<code>stackOut = []</code></p>
</li>
<li><p><strong>入队 1, 2, 3</strong>：<br>• <code>stackIn = [1, 2, 3]</code>，<code>stackOut = []</code></p>
</li>
<li><p><strong>第一次出队</strong>：<br>• 转移 <code>stackIn</code> 到 <code>stackOut</code> → <code>stackOut = [3, 2, 1]</code><br>• 弹出 <code>stackOut</code> 的栈顶元素 <code>1</code>（符合队列顺序）</p>
</li>
<li><p><strong>入队 4</strong>：<br>• <code>stackIn = [4]</code>，<code>stackOut = [3, 2]</code></p>
</li>
<li><p><strong>第二次出队</strong>：<br>• <code>stackOut</code> 不为空，直接弹出栈顶元素 <code>2</code></p>
</li>
</ol>
<hr>
<p>通过这种方式，两个栈协同工作，完美模拟了队列的操作！</p>
<h1 id="讲一讲设计模式，并根据你的项目：苍穹外卖来讲讲你用到了什么设计模式（注意讲一些重点即可）"><a href="#讲一讲设计模式，并根据你的项目：苍穹外卖来讲讲你用到了什么设计模式（注意讲一些重点即可）" class="headerlink" title="讲一讲设计模式，并根据你的项目：苍穹外卖来讲讲你用到了什么设计模式（注意讲一些重点即可）"></a>讲一讲设计模式，并根据你的项目：苍穹外卖来讲讲你用到了什么设计模式（注意讲一些重点即可）</h1><hr>
<h3 id="一、设计模式分类与项目中的典型应用"><a href="#一、设计模式分类与项目中的典型应用" class="headerlink" title="一、设计模式分类与项目中的典型应用"></a>一、设计模式分类与项目中的典型应用</h3><h4 id="1-单例模式（Singleton-Pattern）"><a href="#1-单例模式（Singleton-Pattern）" class="headerlink" title="1. 单例模式（Singleton Pattern）"></a><strong>1. 单例模式（Singleton Pattern）</strong></h4><p>• <strong>作用</strong>：确保一个类仅有一个实例，并提供全局访问点。<br>• <strong>项目应用</strong>：<br>  • <strong>工具类管理</strong>：例如JWT鉴权工具类、Redis配置类等，通过<code>@Component</code>或<code>@Configuration</code>注解实现单例，避免重复创建对象。<br>  • <strong>数据库连接池</strong>：Druid数据源默认使用单例模式管理连接。<br>• <strong>代码示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtUtil</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">SECRET_KEY</span> <span class="operator">=</span> <span class="string">&quot;sky-take-out&quot;</span>;</span><br><span class="line">    <span class="comment">// 单例方法通过Spring容器自动管理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-工厂模式（Factory-Pattern）"><a href="#2-工厂模式（Factory-Pattern）" class="headerlink" title="2. 工厂模式（Factory Pattern）"></a><strong>2. 工厂模式（Factory Pattern）</strong></h4><p>• <strong>作用</strong>：将对象创建逻辑封装，客户端无需关心具体实现。<br>• <strong>项目应用</strong>：<br>  • <strong>Spring的BeanFactory</strong>：通过<code>@Autowired</code>实现依赖注入，例如订单服务（<code>OrderService</code>）和菜品服务（<code>DishService</code>）的实例化。<br>  • <strong>支付策略工厂</strong>：根据用户选择的支付方式（微信、支付宝）动态创建对应的支付处理器。<br>• <strong>场景优势</strong>：解耦对象创建与业务逻辑，便于扩展新支付方式。</p>
<h4 id="3-代理模式（Proxy-Pattern）"><a href="#3-代理模式（Proxy-Pattern）" class="headerlink" title="3. 代理模式（Proxy Pattern）"></a><strong>3. 代理模式（Proxy Pattern）</strong></h4><p>• <strong>作用</strong>：为其他对象提供代理以控制访问。<br>• <strong>项目应用</strong>：<br>  • <strong>Spring AOP</strong>：通过动态代理实现日志记录、事务管理和权限校验。例如，在订单创建时自动开启事务，异常时回滚。<br>  • <strong>Nginx反向代理</strong>：网关层通过反向代理分发请求到不同服务实例，实现负载均衡。<br>• <strong>代码示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Around(&quot;execution(* com.sky.service.*.*(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">logAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> &#123;</span><br><span class="line">        <span class="comment">// 记录方法执行日志</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-观察者模式（Observer-Pattern）"><a href="#4-观察者模式（Observer-Pattern）" class="headerlink" title="4. 观察者模式（Observer Pattern）"></a><strong>4. 观察者模式（Observer Pattern）</strong></h4><p>• <strong>作用</strong>：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖者自动收到通知。<br>• <strong>项目应用</strong>：<br>  • <strong>订单状态变更通知</strong>：当订单状态变为“已完成”时，触发用户端通知、库存扣减和统计数据更新。<br>  • <strong>Spring事件机制</strong>：使用<code>ApplicationEventPublisher</code>发布订单支付成功事件，异步发送短信或微信通知。<br>• <strong>场景优势</strong>：解耦订单处理与通知逻辑，支持灵活扩展监听器。</p>
<h4 id="5-模板方法模式（Template-Method-Pattern）"><a href="#5-模板方法模式（Template-Method-Pattern）" class="headerlink" title="5. 模板方法模式（Template Method Pattern）"></a><strong>5. 模板方法模式（Template Method Pattern）</strong></h4><p>• <strong>作用</strong>：定义算法骨架，允许子类重写特定步骤。<br>• <strong>项目应用</strong>：<br>  • <strong>数据访问层（DAO）</strong>：<code>JdbcTemplate</code>和<code>RedisTemplate</code>封装了数据库操作的通用流程（如连接获取、异常处理），具体SQL由开发者实现。<br>  • <strong>支付流程</strong>：抽象支付流程为“生成订单→调用支付接口→验证结果”，具体支付方式（微信&#x2F;支付宝）实现细节不同。<br>• <strong>代码示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AbstractPaymentHandler</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">processPayment</span><span class="params">(Order order)</span> &#123;</span><br><span class="line">        validate(order);</span><br><span class="line">        callPaymentApi(order);</span><br><span class="line">        updateOrderStatus(order);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">callPaymentApi</span><span class="params">(Order order)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<h3 id="二、其他模式补充"><a href="#二、其他模式补充" class="headerlink" title="二、其他模式补充"></a>二、其他模式补充</h3><h4 id="6-策略模式（Strategy-Pattern）"><a href="#6-策略模式（Strategy-Pattern）" class="headerlink" title="6. 策略模式（Strategy Pattern）"></a><strong>6. 策略模式（Strategy Pattern）</strong></h4><p>• <strong>作用</strong>：定义算法族，使其可互相替换。<br>• <strong>项目应用</strong>：支付模块中，微信支付和支付宝支付实现同一策略接口，通过<code>@Qualifier</code>动态切换。</p>
<h4 id="7-组合模式（Composite-Pattern）"><a href="#7-组合模式（Composite-Pattern）" class="headerlink" title="7. 组合模式（Composite Pattern）"></a><strong>7. 组合模式（Composite Pattern）</strong></h4><p>• <strong>作用</strong>：将对象组合成树形结构以表示“部分-整体”层次。<br>• <strong>项目应用</strong>：菜品分类管理模块中，支持多级分类（如“川菜→火锅→麻辣锅”）的递归展示和操作。</p>
<h4 id="8-责任链模式（Chain-of-Responsibility）"><a href="#8-责任链模式（Chain-of-Responsibility）" class="headerlink" title="8. 责任链模式（Chain of Responsibility）"></a><strong>8. 责任链模式（Chain of Responsibility）</strong></h4><p>• <strong>作用</strong>：将请求的发送者和接收者解耦，使多个对象都有机会处理请求。<br>• <strong>项目应用</strong>：订单处理流程中，依次校验库存、计算优惠、生成支付链接等步骤形成责任链。</p>
<hr>
<h3 id="三、设计模式在项目中的综合价值"><a href="#三、设计模式在项目中的综合价值" class="headerlink" title="三、设计模式在项目中的综合价值"></a>三、设计模式在项目中的综合价值</h3><ol>
<li><strong>代码复用性</strong>：例如模板方法模式减少了DAO层的重复代码。</li>
<li><strong>扩展性</strong>：策略模式支持快速新增支付方式，符合开闭原则。</li>
<li><strong>解耦与维护性</strong>：观察者模式将订单状态变更与通知逻辑分离，便于独立修改。</li>
<li><strong>性能优化</strong>：单例模式避免重复创建资源密集型对象（如数据库连接池）。</li>
</ol>
<hr>
<h3 id="四、项目源码与扩展学习"><a href="#四、项目源码与扩展学习" class="headerlink" title="四、项目源码与扩展学习"></a>四、项目源码与扩展学习</h3><p>• <strong>源码参考</strong>：苍穹外卖的订单模块（<code>OrderService</code>）、支付模块（<code>PaymentService</code>）和工具类（<code>JwtUtil</code>）是设计模式的集中体现。<br>• <strong>进一步建议</strong>：结合Spring框架源码（如<code>BeanFactory</code>、<code>AOP</code>）深入理解模式的实际应用。</p>
<h1 id="如何实现单例模式"><a href="#如何实现单例模式" class="headerlink" title="如何实现单例模式"></a>如何实现单例模式</h1><p>嗯，用户问的是如何实现单例模式。我需要结合提供的搜索结果来整理答案。首先，单例模式的核心是确保一个类只有一个实例，并提供全局访问点。根据搜索结果，不同编程语言有不同的实现方式，但用户可能主要关注Java，因为搜索结果中有多个Java的示例。</p>
<p>搜索结果提到了饿汉式、懒汉式、双重检查锁定、静态内部类和枚举方式。我需要把这些方法分别解释清楚。比如，饿汉式在类加载时就创建实例，线程安全，但可能浪费资源。懒汉式延迟加载，但需要考虑线程安全，可以用同步方法或者双重检查锁定。双重检查锁定结合了懒汉式和同步的优点，减少性能开销。静态内部类利用了类加载机制，既保证线程安全又延迟加载。枚举方式在Java中是最简洁的，还能防止反射攻击。</p>
<p>还要注意每个实现的优缺点，比如饿汉式的资源浪费问题，懒汉式不加锁的线程不安全，双重检查需要volatile防止指令重排序。搜索结果中的例子和代码片段可以帮助构建具体的实现步骤。</p>
<p>另外，用户可能关心实际应用场景，比如配置管理、日志记录器，这些在搜索结果中也有提到。需要结合这些场景说明不同实现方式的适用情况。</p>
<p>最后，总结不同方法的适用情况，帮助用户根据具体需求选择合适的方式。比如高并发下推荐双重检查或静态内部类，简单场景用枚举。同时，要注意线程安全和资源管理的要点，确保用户理解每个方法的关键点。</p>
<p>以下是单例模式的常见实现方式及核心要点总结，结合不同编程语言的特性与线程安全需求，分为经典实现和进阶优化两类：</p>
<hr>
<h3 id="一、经典实现方式"><a href="#一、经典实现方式" class="headerlink" title="一、经典实现方式"></a><strong>一、经典实现方式</strong></h3><h4 id="1-饿汉式（Eager-Initialization）"><a href="#1-饿汉式（Eager-Initialization）" class="headerlink" title="1. 饿汉式（Eager Initialization）"></a><strong>1. 饿汉式（Eager Initialization）</strong></h4><p>• <strong>核心逻辑</strong>：类加载时立即创建实例，线程安全但无法延迟加载。<br>• <strong>Java示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EagerSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">EagerSingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">EagerSingleton</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">EagerSingleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 私有构造方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> EagerSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> instance; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>特点</strong>：<br>  • <strong>优点</strong>：实现简单，线程安全。<br>  • <strong>缺点</strong>：若实例未被使用，可能浪费内存资源。</p>
<hr>
<h4 id="2-懒汉式（Lazy-Initialization）"><a href="#2-懒汉式（Lazy-Initialization）" class="headerlink" title="2. 懒汉式（Lazy Initialization）"></a><strong>2. 懒汉式（Lazy Initialization）</strong></h4><p>• <strong>核心逻辑</strong>：延迟创建实例，需解决线程安全问题。<br>• <strong>基础版（线程不安全）</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">LazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">LazySingleton</span>(); <span class="comment">// 多线程下可能创建多个实例</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>同步方法版（线程安全但性能差）</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncLazySingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncLazySingleton instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SyncLazySingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SyncLazySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> <span class="title class_">SyncLazySingleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>  • <strong>缺点</strong>：每次调用 <code>getInstance()</code> 都需同步，性能低下。</p>
<hr>
<h4 id="3-双重检查锁定（Double-Checked-Locking-DCL）"><a href="#3-双重检查锁定（Double-Checked-Locking-DCL）" class="headerlink" title="3. 双重检查锁定（Double-Checked Locking, DCL）"></a><strong>3. 双重检查锁定（Double-Checked Locking, DCL）</strong></h4><p>• <strong>核心逻辑</strong>：减少同步次数，兼顾线程安全与性能。<br>• <strong>Java示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DCLSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DCLSingleton instance; <span class="comment">// volatile禁止指令重排序</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">DCLSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> DCLSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;                   <span class="comment">// 第一次检查</span></span><br><span class="line">            <span class="keyword">synchronized</span> (DCLSingleton.class) &#123;   <span class="comment">// 同步代码块</span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;            <span class="comment">// 第二次检查</span></span><br><span class="line">                    instance = <span class="keyword">new</span> <span class="title class_">DCLSingleton</span>();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>特点</strong>：<br>  • <strong>优点</strong>：高性能线程安全，适用于高并发场景。<br>  • <strong>注意点</strong>：JDK 1.5+ 需用 <code>volatile</code> 防止指令重排序导致的实例未初始化问题。</p>
<hr>
<h3 id="二、进阶优化方式"><a href="#二、进阶优化方式" class="headerlink" title="二、进阶优化方式"></a><strong>二、进阶优化方式</strong></h3><h4 id="1-静态内部类（Holder模式）"><a href="#1-静态内部类（Holder模式）" class="headerlink" title="1. 静态内部类（Holder模式）"></a><strong>1. 静态内部类（Holder模式）</strong></h4><p>• <strong>核心逻辑</strong>：利用类加载机制保证线程安全，延迟加载且无需同步。<br>• <strong>Java示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HolderSingleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HolderSingleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">HolderSingleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HolderSingleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HolderSingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123; <span class="keyword">return</span> Holder.INSTANCE; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>特点</strong>：<br>  • <strong>优点</strong>：无锁、线程安全、延迟加载。<br>  • <strong>适用场景</strong>：推荐作为Java单例的首选实现。</p>
<hr>
<h4 id="2-枚举单例（Enum-Singleton）"><a href="#2-枚举单例（Enum-Singleton）" class="headerlink" title="2. 枚举单例（Enum Singleton）"></a><strong>2. 枚举单例（Enum Singleton）</strong></h4><p>• <strong>核心逻辑</strong>：通过枚举类型天然防止反射攻击和序列化破坏单例。<br>• <strong>Java示例</strong>：<br>  <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">EnumSingleton</span> &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doSomething</span><span class="params">()</span> &#123; <span class="comment">/* 功能方法 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>特点</strong>：<br>  • <strong>优点</strong>：代码简洁，线程安全，防反射&#x2F;序列化攻击。<br>  • <strong>缺点</strong>：灵活性较差（无法继承其他类）。</p>
<hr>
<h4 id="3-Go语言实现（基于sync-Once）"><a href="#3-Go语言实现（基于sync-Once）" class="headerlink" title="3. Go语言实现（基于sync.Once）"></a><strong>3. Go语言实现（基于<code>sync.Once</code>）</strong></h4><p>• <strong>核心逻辑</strong>：利用 <code>sync.Once</code> 保证初始化只执行一次。<br>• <strong>Go示例</strong>：<br>  <figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="keyword">type</span> Logger <span class="keyword">struct</span> &#123; LogLevel <span class="type">string</span> &#125;</span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    instance *Logger</span><br><span class="line">    once     sync.Once</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetInstance</span><span class="params">()</span></span> *Logger &#123;</span><br><span class="line">    once.Do(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; instance = &amp;Logger&#123;LogLevel: <span class="string">&quot;INFO&quot;</span>&#125; &#125;)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>• <strong>特点</strong>：简洁高效，适用于Go语言的并发场景。</p>
<hr>
<h3 id="三、关键设计原则与注意事项"><a href="#三、关键设计原则与注意事项" class="headerlink" title="三、关键设计原则与注意事项"></a><strong>三、关键设计原则与注意事项</strong></h3><ol>
<li><p><strong>线程安全</strong>：<br>• 饿汉式、枚举、静态内部类天然线程安全。<br>• 懒汉式需通过同步或双重检查锁定实现安全。</p>
</li>
<li><p><strong>防止反射攻击</strong>：<br>• 在私有构造方法中抛出异常，防止通过反射创建实例。</p>
</li>
<li><p><strong>防止序列化破坏</strong>：<br>• 实现 <code>readResolve()</code> 方法返回单例实例，或直接使用枚举。</p>
</li>
<li><p><strong>性能与资源权衡</strong>：<br>• 高并发场景优先选择双重检查锁定或静态内部类。<br>• 简单场景可用枚举或饿汉式。</p>
</li>
</ol>
<hr>
<h3 id="四、实际应用场景"><a href="#四、实际应用场景" class="headerlink" title="四、实际应用场景"></a><strong>四、实际应用场景</strong></h3><p>• <strong>配置管理器</strong>：全局唯一配置对象，避免重复读取文件。<br>• <strong>数据库连接池</strong>：统一管理连接资源，防止过度创建。<br>• <strong>日志记录器</strong>：确保所有日志输出到同一实例。<br>• <strong>缓存系统</strong>：统一管理缓存策略与资源。</p>
<hr>
<h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>实现单例模式的核心在于<strong>控制实例化过程</strong>并<strong>确保全局唯一性</strong>。不同场景下可灵活选择实现方式：<br>• <strong>推荐方式</strong>：静态内部类（Java）、<code>sync.Once</code>（Go）、枚举（防攻击场景）。<br>• <strong>慎用方式</strong>：懒汉式（需严格同步）、饿汉式（资源敏感场景）。</p>
<p>通过合理选择实现策略，单例模式能在保证性能的同时，高效管理系统级资源。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">怪陆离辛</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/">http://example.com/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">格 致</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%98%A5%E6%8B%9B/">春招</a><a class="post-meta__tags" href="/tags/%E5%85%AB%E8%82%A1/">八股</a></div><div class="post_share"><div class="social-share" data-image="/img/12.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%933/" title="高频八股总结3"><img class="cover" src="/img/6.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">高频八股总结3</div></div></a></div><div class="next-post pull-right"><a href="/2025/03/08/%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/" title="常用方法"><img class="cover" src="/img/9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常用方法</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/03/05/%E7%AE%80%E5%8E%86%E7%9F%A5%E8%AF%86%E7%82%B9/" title="简历知识点"><img class="cover" src="/img/10.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">简历知识点</div></div></a></div><div><a href="/2025/03/05/%E9%A1%B9%E7%9B%AEJWT%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%B7%E6%89%93/" title="项目JWT知识点拷打"><img class="cover" src="/img/9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">项目JWT知识点拷打</div></div></a></div><div><a href="/2025/03/05/%E9%A1%B9%E7%9B%AERedis-Lua%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%B7%E6%89%93/" title="项目Redis+Lua知识点拷打"><img class="cover" src="/img/12.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">项目Redis+Lua知识点拷打</div></div></a></div><div><a href="/2025/03/05/%E9%A1%B9%E7%9B%AESpring-Task%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%B7%E6%89%93/" title="项目Spring Task知识点拷打"><img class="cover" src="/img/12.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">项目Spring Task知识点拷打</div></div></a></div><div><a href="/2025/03/05/%E9%A1%B9%E7%9B%AEwebsocket%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%B7%E6%89%93/" title="项目websocket知识点拷打"><img class="cover" src="/img/6.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">项目websocket知识点拷打</div></div></a></div><div><a href="/2025/03/05/%E9%A1%B9%E7%9B%AERedis%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96%E7%9F%A5%E8%AF%86%E7%82%B9%E6%8B%B7%E6%89%93/" title="项目Redis缓存优化知识点拷打"><img class="cover" src="/img/4.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-03-05</div><div class="title">项目Redis缓存优化知识点拷打</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">怪陆离辛</div><div class="author-info__description">Choose what you love</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/gllxgllx"><i class="fab fa-github"></i><span>关注</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://space.bilibili.com/87425918" target="_blank" title="bilibili"><i class="iconfont icon-icon_bilibili"></i></a><a class="social-icon" href="https://wpa.qq.com/msgrd?v=3&amp;uin=202555941&amp;site=qqq&amp;menu=yes" target="_blank" title="qq"><i class="iconfont icon-QQ1"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">转载内容仅供参考和学习</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%92%8CUDP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.</span> <span class="toc-text">TCP和UDP的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%9E%E6%8E%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.1.</span> <span class="toc-text">1. 连接方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.0.2.</span> <span class="toc-text">2. 可靠性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.3.</span> <span class="toc-text">3. 数据传输方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BC%A0%E8%BE%93%E6%95%88%E7%8E%87"><span class="toc-number">1.0.4.</span> <span class="toc-text">4. 传输效率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A4%B4%E9%83%A8%E5%BC%80%E9%94%80"><span class="toc-number">1.0.5.</span> <span class="toc-text">5. 头部开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.6.</span> <span class="toc-text">6. 适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%85%B8%E5%9E%8B%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.0.7.</span> <span class="toc-text">7. 典型协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.8.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HTTP%E5%92%8CHTTPS%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">HTTP和HTTPS的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.0.1.</span> <span class="toc-text">1. 安全性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8D%8F%E8%AE%AE%E4%B8%8E%E7%AB%AF%E5%8F%A3"><span class="toc-number">2.0.2.</span> <span class="toc-text">2. 协议与端口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%A7%E8%83%BD"><span class="toc-number">2.0.3.</span> <span class="toc-text">3. 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AF%81%E4%B9%A6"><span class="toc-number">2.0.4.</span> <span class="toc-text">4. 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">2.0.5.</span> <span class="toc-text">5. 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-SEO-%E5%BD%B1%E5%93%8D"><span class="toc-number">2.0.6.</span> <span class="toc-text">6. SEO 影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">2.0.7.</span> <span class="toc-text">7. 实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A0%87%E8%AF%86"><span class="toc-number">2.0.8.</span> <span class="toc-text">8. 浏览器标识</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">2.0.9.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE"><span class="toc-number">2.0.10.</span> <span class="toc-text">建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">3.</span> <span class="toc-text">快速排序的思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E9%80%89%E6%8B%A9%E5%9F%BA%E5%87%86%E5%85%83%E7%B4%A0"><span class="toc-number">3.0.1.</span> <span class="toc-text">1. 选择基准元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%88%86%E5%8C%BA%EF%BC%88Partition%EF%BC%89"><span class="toc-number">3.0.2.</span> <span class="toc-text">2. 分区（Partition）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%80%92%E5%BD%92%E6%8E%92%E5%BA%8F"><span class="toc-number">3.0.3.</span> <span class="toc-text">3. 递归排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BB%88%E6%AD%A2%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. 终止条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.0.5.</span> <span class="toc-text">代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.0.6.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">3.0.7.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96"><span class="toc-number">3.0.8.</span> <span class="toc-text">优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">3.0.9.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.</span> <span class="toc-text">异常和错误了解吗，区别是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%BC%82%E5%B8%B8%EF%BC%88Exception%EF%BC%89"><span class="toc-number">4.0.1.</span> <span class="toc-text">1. 异常（Exception）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%94%99%E8%AF%AF%EF%BC%88Error%EF%BC%89"><span class="toc-number">4.0.2.</span> <span class="toc-text">2. 错误（Error）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8C%BA%E5%88%AB"><span class="toc-number">4.0.3.</span> <span class="toc-text">3. 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%80%BB%E7%BB%93"><span class="toc-number">4.0.4.</span> <span class="toc-text">4. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%8C%E8%AF%B4%E4%B8%80%E4%B8%8B"><span class="toc-number">5.</span> <span class="toc-text">HashMap底层实现了解吗，说一下</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.1.</span> <span class="toc-text">1. 数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E5%B1%9E%E6%80%A7"><span class="toc-number">5.0.2.</span> <span class="toc-text">2. 核心属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95"><span class="toc-number">5.0.3.</span> <span class="toc-text">3. 核心方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-put-K-key-V-value"><span class="toc-number">5.0.3.1.</span> <span class="toc-text">3.1 put(K key, V value)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-get-Object-key"><span class="toc-number">5.0.3.2.</span> <span class="toc-text">3.2 get(Object key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-resize"><span class="toc-number">5.0.3.3.</span> <span class="toc-text">3.3 resize()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E8%A7%A3%E5%86%B3"><span class="toc-number">5.0.4.</span> <span class="toc-text">4. 哈希冲突解决</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%80%A7%E8%83%BD"><span class="toc-number">5.0.5.</span> <span class="toc-text">5. 性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.0.6.</span> <span class="toc-text">6. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">5.0.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">6.</span> <span class="toc-text">红黑树了解吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.0.1.</span> <span class="toc-text">1. 红黑树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">6.0.2.</span> <span class="toc-text">2. 红黑树的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%8F%92%E5%85%A5"><span class="toc-number">6.0.2.1.</span> <span class="toc-text">2.1 插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E5%88%A0%E9%99%A4"><span class="toc-number">6.0.2.2.</span> <span class="toc-text">2.2 删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E6%9F%A5%E6%89%BE"><span class="toc-number">6.0.2.3.</span> <span class="toc-text">2.3 查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">6.0.3.</span> <span class="toc-text">3. 红黑树的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%BA%A2%E9%BB%91%E6%A0%91%E4%B8%8E-AVL-%E6%A0%91%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.0.4.</span> <span class="toc-text">4. 红黑树与 AVL 树的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%BA%A2%E9%BB%91%E6%A0%91%E5%9C%A8-Java-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">6.0.5.</span> <span class="toc-text">5. 红黑树在 Java 中的应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">6.0.6.</span> <span class="toc-text">6. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93-1"><span class="toc-number">6.0.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#HashMap%E6%98%AF%E5%90%A6%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%8C%E4%B8%BA%E4%BD%95"><span class="toc-number">7.</span> <span class="toc-text">HashMap是否线程安全，为何</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4"><span class="toc-number">7.0.1.</span> <span class="toc-text">1. 数据不一致</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.0.2.</span> <span class="toc-text">2. 死循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%BB%93%E6%9E%84%E4%BF%AE%E6%94%B9%E5%BC%82%E5%B8%B8"><span class="toc-number">7.0.3.</span> <span class="toc-text">3. 结构修改异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88-HashMap-%E4%B8%8D%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%EF%BC%9F"><span class="toc-number">7.0.4.</span> <span class="toc-text">4. 为什么 HashMap 不是线程安全的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84-HashMap%EF%BC%9F"><span class="toc-number">7.0.5.</span> <span class="toc-text">5. 如何实现线程安全的 HashMap？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">7.0.6.</span> <span class="toc-text">6. 示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93-2"><span class="toc-number">7.0.7.</span> <span class="toc-text">7. 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Java%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">8.</span> <span class="toc-text">Java的内存管理有哪几种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%EF%BC%89"><span class="toc-number">8.0.1.</span> <span class="toc-text">1. 自动内存管理（垃圾回收机制）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%A0%86%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.0.2.</span> <span class="toc-text">2. 堆内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%88%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">8.0.3.</span> <span class="toc-text">3. 栈内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%96%B9%E6%B3%95%E5%8C%BA%EF%BC%88%E5%85%83%E7%A9%BA%E9%97%B4%EF%BC%89"><span class="toc-number">8.0.4.</span> <span class="toc-text">4. 方法区（元空间）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="toc-number">8.0.5.</span> <span class="toc-text">5. 本地方法栈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="toc-number">8.0.6.</span> <span class="toc-text">6. 直接内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5"><span class="toc-number">8.0.7.</span> <span class="toc-text">7. 内存分配策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%A4%84%E7%90%86"><span class="toc-number">8.0.8.</span> <span class="toc-text">8. 内存泄漏处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-JVM%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98"><span class="toc-number">8.0.9.</span> <span class="toc-text">9. JVM参数调优</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">8.0.10.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97"><span class="toc-number">9.</span> <span class="toc-text">垃圾回收算法了解吗</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95%EF%BC%88Mark-Sweep%EF%BC%89"><span class="toc-number">9.0.1.</span> <span class="toc-text">1. 标记-清除算法（Mark-Sweep）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95%EF%BC%88Mark-Compact%EF%BC%89"><span class="toc-number">9.0.2.</span> <span class="toc-text">2. 标记-整理算法（Mark-Compact）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95%EF%BC%88Copying%EF%BC%89"><span class="toc-number">9.0.3.</span> <span class="toc-text">3. 复制算法（Copying）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%88%86%E4%BB%A3%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Generational-Collection%EF%BC%89"><span class="toc-number">9.0.4.</span> <span class="toc-text">4. 分代收集算法（Generational Collection）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%A2%9E%E9%87%8F%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%EF%BC%88Incremental-GC%EF%BC%89"><span class="toc-number">9.0.5.</span> <span class="toc-text">5. 增量收集算法（Incremental GC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-G1%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%EF%BC%88Garbage-First%EF%BC%89"><span class="toc-number">9.0.6.</span> <span class="toc-text">6. G1垃圾回收器（Garbage-First）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-number">9.0.7.</span> <span class="toc-text">面试回答示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%88%86%E5%88%AB%E8%AE%B2%E8%A7%A3%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%B4%E8%AF%B4%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF4%E6%AC%A1%E6%8C%A5%E6%89%8B%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1"><span class="toc-number">10.</span> <span class="toc-text">TCP协议三次握手，四次挥手分别讲解，并且说说为什么是4次挥手不是三次</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">10.0.1.</span> <span class="toc-text">TCP协议的三次握手与四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%88%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-number">10.0.2.</span> <span class="toc-text">1. 三次握手（建立连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%EF%BC%89"><span class="toc-number">10.0.3.</span> <span class="toc-text">2. 四次挥手（断开连接）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%8C%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%89%E6%AC%A1%EF%BC%9F"><span class="toc-number">10.0.4.</span> <span class="toc-text">为什么是四次挥手，而不是三次？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B%EF%BC%9A-1"><span class="toc-number">10.0.5.</span> <span class="toc-text">面试回答示例：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E4%BF%97%E6%98%93%E6%87%82%E7%9A%84%E8%A7%A3%E9%87%8A%EF%BC%9A"><span class="toc-number">10.0.6.</span> <span class="toc-text">通俗易懂的解释：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%90%8C%E6%AD%A5%E6%A0%87%E5%BF%97%EF%BC%88SYN%EF%BC%89"><span class="toc-number">10.0.7.</span> <span class="toc-text">1. 同步标志（SYN）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%BA%8F%E5%88%97%E5%8F%B7%EF%BC%88seq%EF%BC%89"><span class="toc-number">10.0.8.</span> <span class="toc-text">2. 序列号（seq）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E7%A1%AE%E8%AE%A4%E6%A0%87%E5%BF%97%EF%BC%88ACK%EF%BC%89"><span class="toc-number">10.0.9.</span> <span class="toc-text">3. 确认标志（ACK）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E7%A1%AE%E8%AE%A4%E5%8F%B7%EF%BC%88ack%EF%BC%89"><span class="toc-number">10.0.10.</span> <span class="toc-text">4. 确认号（ack）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%EF%BC%88%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%89%EF%BC%9A"><span class="toc-number">10.0.11.</span> <span class="toc-text">举例说明（三次握手）：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A"><span class="toc-number">10.0.12.</span> <span class="toc-text">总结：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E5%9B%9E%E7%AD%94%E7%A4%BA%E4%BE%8B%EF%BC%9A-2"><span class="toc-number">10.0.13.</span> <span class="toc-text">面试回答示例：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8"><span class="toc-number">11.</span> <span class="toc-text">TCP如何保证传输安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%EF%BC%88Retransmission%EF%BC%89"><span class="toc-number">11.0.1.</span> <span class="toc-text">3. 超时重传（Retransmission）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">11.0.1.1.</span> <span class="toc-text">作用与实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-1"><span class="toc-number">11.0.1.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%88Flow-Control%EF%BC%89"><span class="toc-number">11.0.2.</span> <span class="toc-text">4. 流量控制（Flow Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-1"><span class="toc-number">11.0.2.1.</span> <span class="toc-text">作用与实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">11.0.2.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%EF%BC%88Congestion-Control%EF%BC%89"><span class="toc-number">11.0.3.</span> <span class="toc-text">5. 拥塞控制（Congestion Control）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86-2"><span class="toc-number">11.0.3.1.</span> <span class="toc-text">作用与实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3"><span class="toc-number">11.0.3.2.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">11.0.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="toc-number">12.</span> <span class="toc-text">用两个栈实现队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E8%B7%AF"><span class="toc-number">12.0.1.</span> <span class="toc-text">核心思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.0.2.</span> <span class="toc-text">Java代码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E9%80%BB%E8%BE%91%E8%A7%A3%E9%87%8A"><span class="toc-number">12.0.3.</span> <span class="toc-text">关键逻辑解释</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">12.0.4.</span> <span class="toc-text">时间复杂度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%A4%E4%B8%AA%E6%A0%88%EF%BC%9F"><span class="toc-number">12.0.5.</span> <span class="toc-text">为什么需要两个栈？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E6%B5%81%E7%A8%8B"><span class="toc-number">12.0.6.</span> <span class="toc-text">示例流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%B2%E4%B8%80%E8%AE%B2%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%8C%E5%B9%B6%E6%A0%B9%E6%8D%AE%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%EF%BC%9A%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%9D%A5%E8%AE%B2%E8%AE%B2%E4%BD%A0%E7%94%A8%E5%88%B0%E4%BA%86%E4%BB%80%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88%E6%B3%A8%E6%84%8F%E8%AE%B2%E4%B8%80%E4%BA%9B%E9%87%8D%E7%82%B9%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">13.</span> <span class="toc-text">讲一讲设计模式，并根据你的项目：苍穹外卖来讲讲你用到了什么设计模式（注意讲一些重点即可）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB%E4%B8%8E%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">13.0.1.</span> <span class="toc-text">一、设计模式分类与项目中的典型应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%EF%BC%88Singleton-Pattern%EF%BC%89"><span class="toc-number">13.0.1.1.</span> <span class="toc-text">1. 单例模式（Singleton Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%EF%BC%88Factory-Pattern%EF%BC%89"><span class="toc-number">13.0.1.2.</span> <span class="toc-text">2. 工厂模式（Factory Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%EF%BC%88Proxy-Pattern%EF%BC%89"><span class="toc-number">13.0.1.3.</span> <span class="toc-text">3. 代理模式（Proxy Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%88Observer-Pattern%EF%BC%89"><span class="toc-number">13.0.1.4.</span> <span class="toc-text">4. 观察者模式（Observer Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%EF%BC%88Template-Method-Pattern%EF%BC%89"><span class="toc-number">13.0.1.5.</span> <span class="toc-text">5. 模板方法模式（Template Method Pattern）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%85%B6%E4%BB%96%E6%A8%A1%E5%BC%8F%E8%A1%A5%E5%85%85"><span class="toc-number">13.0.2.</span> <span class="toc-text">二、其他模式补充</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Strategy-Pattern%EF%BC%89"><span class="toc-number">13.0.2.1.</span> <span class="toc-text">6. 策略模式（Strategy Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%EF%BC%88Composite-Pattern%EF%BC%89"><span class="toc-number">13.0.2.2.</span> <span class="toc-text">7. 组合模式（Composite Pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%EF%BC%88Chain-of-Responsibility%EF%BC%89"><span class="toc-number">13.0.2.3.</span> <span class="toc-text">8. 责任链模式（Chain of Responsibility）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%9C%A8%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%9A%84%E7%BB%BC%E5%90%88%E4%BB%B7%E5%80%BC"><span class="toc-number">13.0.3.</span> <span class="toc-text">三、设计模式在项目中的综合价值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%A1%B9%E7%9B%AE%E6%BA%90%E7%A0%81%E4%B8%8E%E6%89%A9%E5%B1%95%E5%AD%A6%E4%B9%A0"><span class="toc-number">13.0.4.</span> <span class="toc-text">四、项目源码与扩展学习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.</span> <span class="toc-text">如何实现单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E7%BB%8F%E5%85%B8%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">14.0.1.</span> <span class="toc-text">一、经典实现方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%A5%BF%E6%B1%89%E5%BC%8F%EF%BC%88Eager-Initialization%EF%BC%89"><span class="toc-number">14.0.1.1.</span> <span class="toc-text">1. 饿汉式（Eager Initialization）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%87%92%E6%B1%89%E5%BC%8F%EF%BC%88Lazy-Initialization%EF%BC%89"><span class="toc-number">14.0.1.2.</span> <span class="toc-text">2. 懒汉式（Lazy Initialization）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%EF%BC%88Double-Checked-Locking-DCL%EF%BC%89"><span class="toc-number">14.0.1.3.</span> <span class="toc-text">3. 双重检查锁定（Double-Checked Locking, DCL）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E8%BF%9B%E9%98%B6%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">14.0.2.</span> <span class="toc-text">二、进阶优化方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%EF%BC%88Holder%E6%A8%A1%E5%BC%8F%EF%BC%89"><span class="toc-number">14.0.2.1.</span> <span class="toc-text">1. 静态内部类（Holder模式）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9E%9A%E4%B8%BE%E5%8D%95%E4%BE%8B%EF%BC%88Enum-Singleton%EF%BC%89"><span class="toc-number">14.0.2.2.</span> <span class="toc-text">2. 枚举单例（Enum Singleton）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Go%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0%EF%BC%88%E5%9F%BA%E4%BA%8Esync-Once%EF%BC%89"><span class="toc-number">14.0.2.3.</span> <span class="toc-text">3. Go语言实现（基于sync.Once）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8E%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">14.0.3.</span> <span class="toc-text">三、关键设计原则与注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">14.0.4.</span> <span class="toc-text">四、实际应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-5"><span class="toc-number">14.0.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84java%E6%A1%88%E4%BE%8B/" title="数据机构java案例"><img src="/img/5.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据机构java案例"/></a><div class="content"><a class="title" href="/2025/03/08/%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84java%E6%A1%88%E4%BE%8B/" title="数据机构java案例">数据机构java案例</a><time datetime="2025-03-08T13:47:34.000Z" title="发表于 2025-03-08 21:47:34">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84java/" title="数据结构java"><img src="/img/4.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构java"/></a><div class="content"><a class="title" href="/2025/03/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84java/" title="数据结构java">数据结构java</a><time datetime="2025-03-08T13:47:21.000Z" title="发表于 2025-03-08 21:47:21">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%934/" title="高频八股总结4"><img src="/img/8.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高频八股总结4"/></a><div class="content"><a class="title" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%934/" title="高频八股总结4">高频八股总结4</a><time datetime="2025-03-08T11:56:50.000Z" title="发表于 2025-03-08 19:56:50">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%933/" title="高频八股总结3"><img src="/img/6.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高频八股总结3"/></a><div class="content"><a class="title" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%933/" title="高频八股总结3">高频八股总结3</a><time datetime="2025-03-08T11:56:45.000Z" title="发表于 2025-03-08 19:56:45">2025-03-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/" title="高频八股总结2"><img src="/img/12.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="高频八股总结2"/></a><div class="content"><a class="title" href="/2025/03/08/%E9%AB%98%E9%A2%91%E5%85%AB%E8%82%A1%E6%80%BB%E7%BB%932/" title="高频八股总结2">高频八股总结2</a><time datetime="2025-03-08T07:44:45.000Z" title="发表于 2025-03-08 15:44:45">2025-03-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2025 By 怪陆离辛</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">The exploration is endless</div></div><div class="container" id="jsi-flying-fish-container"><script src="js/fish.js"></script></div><style>   @media only screen and (max-width: 767px){
   #sidebar_search_box input[type=text]{width:calc(100% - 24px)}
}</style></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><script>(()=>{
  const init = () => {
    twikoo.init(Object.assign({
      el: '#twikoo-wrap',
      envId: 'https://gllxtwikoo.zeabur.app',
      region: 'ap-beijing',
      onCommentLoaded: function () {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      }
    }, null))
  }

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://gllxtwikoo.zeabur.app',
      region: 'ap-beijing',
      urls: [window.location.pathname],
      includeReply: false
    }).then(function (res) {
      countELement.innerText = res[0].count
    }).catch(function (err) {
      console.error(err);
    });
  }

  const runFn = () => {
    init()
    GLOBAL_CONFIG_SITE.isPost && getCount()
  }

  const loadTwikoo = () => {
    if (typeof twikoo === 'object') {
      setTimeout(runFn,0)
      return
    } 
    getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(runFn)
  }

  if ('Twikoo' === 'Twikoo' || !true) {
    if (true) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = () => {
      loadTwikoo()
    }
  }
})()</script></div><script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/xiabo2/CDN@latest/fish.js"></script><script src="/js/sakura.js"></script><script src="/js/xxx.js"></script><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></body></html>