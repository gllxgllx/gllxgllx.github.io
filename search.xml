<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>简历知识点</title>
      <link href="/2025/03/05/%E7%AE%80%E5%8E%86%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2025/03/05/%E7%AE%80%E5%8E%86%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="一、技术基础"><a href="#一、技术基础" class="headerlink" title="一、技术基础"></a><strong>一、技术基础</strong></h3><h4 id="1-Java核心"><a href="#1-Java核心" class="headerlink" title="1. Java核心"></a>1. <strong>Java核心</strong></h4><p>   • <strong>集合</strong>：HashMap底层结构（数组+链表&#x2F;红黑树）、ConcurrentHashMap分段锁机制、ArrayList vs LinkedList<br>   • <strong>并发</strong>：synchronized锁升级过程、ReentrantLock的AQS实现、线程池参数（核心&#x2F;最大线程数、队列类型）<br>   • <strong>JVM</strong>：内存分区（堆、栈、方法区）、GC算法（CMS&#x2F;G1区别）、OOM排查工具（jstat、MAT）</p><h4 id="2-数据库"><a href="#2-数据库" class="headerlink" title="2. 数据库"></a>2. <strong>数据库</strong></h4><p>   • <strong>事务</strong>：ACID特性、脏读&#x2F;不可重复读&#x2F;幻读场景、MVCC实现原理<br>   • <strong>索引</strong>：B+树结构、最左前缀原则、覆盖索引优化、索引失效场景（如LIKE “%xx”）<br>   • <strong>锁</strong>：行锁 vs 表锁、死锁检测（SHOW ENGINE INNODB STATUS）</p><h4 id="3-Spring框架"><a href="#3-Spring框架" class="headerlink" title="3. Spring框架"></a>3. <strong>Spring框架</strong></h4><p>   • <strong>IOC</strong>：Bean生命周期、依赖注入方式（构造器 vs @Autowired）<br>   • <strong>AOP</strong>：动态代理（JDK&#x2F;CGLIB）、切面执行顺序（@Order）、事务传播机制</p><h4 id="4-Redis"><a href="#4-Redis" class="headerlink" title="4. Redis"></a>4. <strong>Redis</strong></h4><p>   • <strong>缓存穿透&#x2F;雪崩&#x2F;击穿</strong>：解决方案（布隆过滤器、随机过期时间、互斥锁）<br>   • <strong>数据结构</strong>：String&#x2F;Hash适用场景、ZSet跳表实现、持久化机制（RDB&#x2F;AOF）<br>   • <strong>分布式锁</strong>：Redisson看门狗机制、与ZooKeeper对比</p><h4 id="5-设计模式"><a href="#5-设计模式" class="headerlink" title="5. 设计模式"></a>5. <strong>设计模式</strong></h4><p>   • <strong>单例</strong>：双重检查锁、静态内部类实现<br>   • <strong>工厂模式</strong>：Spring BeanFactory vs FactoryBean<br>   • <strong>代理模式</strong>：动态代理在Spring AOP中的应用</p><hr><h3 id="二、项目亮点"><a href="#二、项目亮点" class="headerlink" title="二、项目亮点"></a><strong>二、项目亮点</strong></h3><h4 id="1-JWT身份验证"><a href="#1-JWT身份验证" class="headerlink" title="1. JWT身份验证"></a>1. <strong>JWT身份验证</strong></h4><p>   • <strong>技术点</strong>：Token结构（Header&#x2F;Payload&#x2F;Signature）、如何防篡改（签名算法）<br>   • <strong>优化</strong>：ThreadLocal保存用户上下文、拦截器链的执行顺序</p><h4 id="2-分布式锁（Redis-Lua）"><a href="#2-分布式锁（Redis-Lua）" class="headerlink" title="2. 分布式锁（Redis + Lua）"></a>2. <strong>分布式锁（Redis + Lua）</strong></h4><p>   • <strong>关键逻辑</strong>：Lua脚本保证原子性、锁续期问题（需说明未实现续期的潜在风险）<br>   • <strong>对比方案</strong>：Redisson的看门狗机制、ZooKeeper临时有序节点</p><h4 id="3-Redis缓存设计"><a href="#3-Redis缓存设计" class="headerlink" title="3. Redis缓存设计"></a>3. <strong>Redis缓存设计</strong></h4><p>   • <strong>淘汰策略</strong>：LRU vs LFU、缓存预热&#x2F;降级方案<br>   • <strong>一致性</strong>：双写一致性方案（先更新库还是先删缓存？）</p><h4 id="4-WebSocket长连接"><a href="#4-WebSocket长连接" class="headerlink" title="4. WebSocket长连接"></a>4. <strong>WebSocket长连接</strong></h4><p>   • <strong>对比HTTP轮询</strong>：减少无效请求、如何解决断线重连<br>   • <strong>性能优化</strong>：心跳机制、连接数管理（Netty的ChannelGroup）</p><h4 id="5-Spring-Task定时任务"><a href="#5-Spring-Task定时任务" class="headerlink" title="5. Spring Task定时任务"></a>5. <strong>Spring Task定时任务</strong></h4><p>   • <strong>缺点</strong>：单机任务阻塞问题、集群环境下任务重复执行<br>   • <strong>替代方案</strong>：分布式任务框架（XXL-JOB、Quartz）</p><h4 id="6-分布式Session"><a href="#6-分布式Session" class="headerlink" title="6. 分布式Session"></a>6. <strong>分布式Session</strong></h4><p>   • <strong>Hash vs String</strong>：内存节省原理（Hash字段独立存储）、部分更新优势<br>   • <strong>扩展问题</strong>：Redis集群下Session同步方案（一致性哈希）</p><hr><h3 id="三、扩展问题"><a href="#三、扩展问题" class="headerlink" title="三、扩展问题"></a><strong>三、扩展问题</strong></h3><ol><li><strong>系统设计</strong>：如何设计一个高并发秒杀系统（限流、削峰、异步扣库存）？</li><li><strong>场景题</strong>：订单超时未支付如何实现？（Redis过期Key监听 vs 延迟队列）</li><li><strong>故障排查</strong>：线上接口响应慢，如何定位问题？（链路追踪、慢SQL分析、线程Dump）</li><li><strong>优化经验</strong>：项目中遇到的最大性能瓶颈是什么？如何解决的？</li></ol><hr><h3 id="四、软技能"><a href="#四、软技能" class="headerlink" title="四、软技能"></a><strong>四、软技能</strong></h3><ol><li><strong>项目难点</strong>：用STAR法则描述一个技术挑战（如高并发下的超卖问题）。</li><li><strong>团队协作</strong>：如何与前端&#x2F;测试协作？代码冲突如何解决？</li><li><strong>学习能力</strong>：最近学习的开源技术（如RocketMQ、Elasticsearch）。</li></ol><hr><h3 id="五、高频问题示例"><a href="#五、高频问题示例" class="headerlink" title="五、高频问题示例"></a><strong>五、高频问题示例</strong></h3><ol><li><strong>JWT的优缺点</strong>：无状态 vs 无法主动失效（需结合Redis黑名单解决）。</li><li><strong>为什么用Lua脚本</strong>：保证原子性（避免客户端多命令执行失败）。</li><li><strong>ThreadLocal内存泄漏</strong>：为什么用弱引用？如何避免（remove()清理）？</li><li><strong>Spring Boot自动配置</strong>：@EnableAutoConfiguration原理（spring.factories加载）。</li></ol><hr><p><strong>准备建议</strong>：<br>• <strong>技术细节</strong>：每个功能点至少能说出2种实现方案及其优缺点。<br>• <strong>项目闭环</strong>：数据验证（如缓存命中率提升多少？超卖降低多少？）。<br>• <strong>模拟面试</strong>：找朋友模拟技术深挖，尤其是项目中的技术选型逻辑。  </p><p>祝面试顺利！ 🚀</p>]]></content>
      
      
      
        <tags>
            
            <tag> 春招 </tag>
            
            <tag> 简历 </tag>
            
            <tag> 八股 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苍穹外卖技术要点1</title>
      <link href="/2025/03/02/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B91/"/>
      <url>/2025/03/02/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96%E6%8A%80%E6%9C%AF%E8%A6%81%E7%82%B91/</url>
      
        <content type="html"><![CDATA[<hr><h3 id="1-登录及身份验证（JWT-ThreadLocal-拦截器）"><a href="#1-登录及身份验证（JWT-ThreadLocal-拦截器）" class="headerlink" title="1. 登录及身份验证（JWT + ThreadLocal + 拦截器）"></a>1. <strong>登录及身份验证（JWT + ThreadLocal + 拦截器）</strong></h3><h4 id="实现步骤："><a href="#实现步骤：" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>引入依赖</strong>：<br>在<code>pom.xml</code>中引入JWT和Spring Security相关依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.jsonwebtoken<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jjwt<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>生成JWT Token</strong>：<br>在用户登录成功后，生成JWT Token并返回给客户端：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">generateToken</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Jwts.builder()</span><br><span class="line">            .setSubject(user.getUsername())</span><br><span class="line">            .setExpiration(<span class="keyword">new</span> <span class="title class_">Date</span>(System.currentTimeMillis() + EXPIRATION_TIME))</span><br><span class="line">            .signWith(SignatureAlgorithm.HS512, SECRET_KEY)</span><br><span class="line">            .compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>拦截器校验Token</strong>：<br>自定义拦截器，解析并校验Token：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JwtInterceptor</span> <span class="keyword">implements</span> <span class="title class_">HandlerInterceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">token</span> <span class="operator">=</span> request.getHeader(<span class="string">&quot;Authorization&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (token != <span class="literal">null</span> &amp;&amp; validateToken(token)) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">username</span> <span class="operator">=</span> getUsernameFromToken(token);</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> userService.findByUsername(username);</span><br><span class="line">            UserContext.setCurrentUser(user); <span class="comment">// 将用户信息存入ThreadLocal</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setStatus(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>配置拦截器</strong>：<br>在Spring Boot中注册拦截器：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebConfig</span> <span class="keyword">implements</span> <span class="title class_">WebMvcConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> &#123;</span><br><span class="line">        registry.addInterceptor(<span class="keyword">new</span> <span class="title class_">JwtInterceptor</span>()).addPathPatterns(<span class="string">&quot;/api/**&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>ThreadLocal存储用户信息</strong>：<br>使用<code>ThreadLocal</code>存储当前登录用户信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserContext</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;User&gt; currentUser = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setCurrentUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">        currentUser.set(user);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> User <span class="title function_">getCurrentUser</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> currentUser.get();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        currentUser.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-分布式锁（Redis-Lua脚本）"><a href="#2-分布式锁（Redis-Lua脚本）" class="headerlink" title="2. 分布式锁（Redis + Lua脚本）"></a>2. <strong>分布式锁（Redis + Lua脚本）</strong></h3><h4 id="实现步骤：-1"><a href="#实现步骤：-1" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>引入依赖</strong>：<br>在<code>pom.xml</code>中引入Redis依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>实现分布式锁</strong>：<br>使用Redis的<code>SETNX</code>命令实现分布式锁，并通过Lua脚本保证原子性：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(String key, String value, <span class="type">long</span> expireTime)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> redisTemplate.opsForValue().setIfAbsent(key, value, expireTime, TimeUnit.SECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">(String key, String value)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">script</span> <span class="operator">=</span> <span class="string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;</span><br><span class="line">    redisTemplate.execute(<span class="keyword">new</span> <span class="title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Collections.singletonList(key), value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="3-菜品缓存（Redis）"><a href="#3-菜品缓存（Redis）" class="headerlink" title="3. 菜品缓存（Redis）"></a>3. <strong>菜品缓存（Redis）</strong></h3><h4 id="实现步骤：-2"><a href="#实现步骤：-2" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>缓存菜品信息</strong>：<br>在查询菜品信息时，优先从Redis缓存中获取：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Dish <span class="title function_">getDishById</span><span class="params">(Long id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish:&quot;</span> + id;</span><br><span class="line">    <span class="type">Dish</span> <span class="variable">dish</span> <span class="operator">=</span> redisTemplate.opsForValue().get(key);</span><br><span class="line">    <span class="keyword">if</span> (dish == <span class="literal">null</span>) &#123;</span><br><span class="line">        dish = dishRepository.findById(id).orElse(<span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (dish != <span class="literal">null</span>) &#123;</span><br><span class="line">            redisTemplate.opsForValue().set(key, dish, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dish;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>更新缓存</strong>：<br>在菜品信息更新时，同步更新缓存：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">updateDish</span><span class="params">(Dish dish)</span> &#123;</span><br><span class="line">    dishRepository.save(dish);</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;dish:&quot;</span> + dish.getId();</span><br><span class="line">    redisTemplate.opsForValue().set(key, dish, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="4-长连接（WebSocket）"><a href="#4-长连接（WebSocket）" class="headerlink" title="4. 长连接（WebSocket）"></a>4. <strong>长连接（WebSocket）</strong></h3><h4 id="实现步骤：-3"><a href="#实现步骤：-3" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>引入依赖</strong>：<br>在<code>pom.xml</code>中引入WebSocket依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-websocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置WebSocket</strong>：<br>在Spring Boot中配置WebSocket：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebSocket</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WebSocketConfig</span> <span class="keyword">implements</span> <span class="title class_">WebSocketConfigurer</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">registerWebSocketHandlers</span><span class="params">(WebSocketHandlerRegistry registry)</span> &#123;</span><br><span class="line">        registry.addHandler(<span class="keyword">new</span> <span class="title class_">OrderWebSocketHandler</span>(), <span class="string">&quot;/ws/order&quot;</span>).setAllowedOrigins(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现WebSocket处理器</strong>：<br>自定义WebSocket处理器，处理客户端消息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderWebSocketHandler</span> <span class="keyword">extends</span> <span class="title class_">TextWebSocketHandler</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">handleTextMessage</span><span class="params">(WebSocketSession session, TextMessage message)</span> &#123;</span><br><span class="line">        <span class="comment">// 处理客户端消息</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="5-定时任务（Spring-Task）"><a href="#5-定时任务（Spring-Task）" class="headerlink" title="5. 定时任务（Spring Task）"></a>5. <strong>定时任务（Spring Task）</strong></h3><h4 id="实现步骤：-4"><a href="#实现步骤：-4" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>启用定时任务</strong>：<br>在Spring Boot启动类上添加<code>@EnableScheduling</code>注解：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableScheduling</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>实现定时任务</strong>：<br>使用<code>@Scheduled</code>注解定义定时任务：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderTask</span> &#123;</span><br><span class="line">    <span class="meta">@Scheduled(cron = &quot;0 0/5 * * * ?&quot;)</span> <span class="comment">// 每5分钟执行一次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">cancelExpiredOrders</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 取消超时订单</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="6-分布式Session（Redis-Hash）"><a href="#6-分布式Session（Redis-Hash）" class="headerlink" title="6. 分布式Session（Redis + Hash）"></a>6. <strong>分布式Session（Redis + Hash）</strong></h3><h4 id="实现步骤：-5"><a href="#实现步骤：-5" class="headerlink" title="实现步骤："></a>实现步骤：</h4><ol><li><p><strong>引入依赖</strong>：<br>在<code>pom.xml</code>中引入Spring Session和Redis依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>配置分布式Session</strong>：<br>在<code>application.properties</code>中配置Session存储为Redis：</p><figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring.session.store-type</span>=<span class="string">redis</span></span><br></pre></td></tr></table></figure></li><li><p><strong>使用Hash存储用户信息</strong>：<br>在Redis中使用Hash存储用户信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">saveUser</span><span class="params">(User user)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> <span class="string">&quot;user:&quot;</span> + user.getId();</span><br><span class="line">    redisTemplate.opsForHash().put(key, <span class="string">&quot;username&quot;</span>, user.getUsername());</span><br><span class="line">    redisTemplate.opsForHash().put(key, <span class="string">&quot;email&quot;</span>, user.getEmail());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Spring Boot中实现这些技术点，主要通过以下步骤：</p><ol><li><strong>引入相关依赖</strong>：如JWT、Redis、WebSocket等。</li><li><strong>配置Spring Boot</strong>：如拦截器、WebSocket、定时任务等。</li><li><strong>编写业务逻辑</strong>：如Token生成、分布式锁、缓存处理等。</li><li><strong>优化性能</strong>：如使用Redis缓存、分布式锁、WebSocket等。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 招聘 </tag>
            
            <tag> 项目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tplink笔试第一次</title>
      <link href="/2025/02/11/tplink%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E6%AC%A1/"/>
      <url>/2025/02/11/tplink%E7%AC%94%E8%AF%95%E7%AC%AC%E4%B8%80%E6%AC%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="笔试题目："><a href="#笔试题目：" class="headerlink" title="笔试题目："></a>笔试题目：</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目 1"></a>题目 1</h2><p>有如下代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">foobar</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> foo1;</span><br><span class="line">    <span class="type">int</span> foo2;</span><br><span class="line">&#125;FOOBAR;</span><br></pre></td></tr></table></figure><p>在32位处理器上，<code>sizeof(FOOBAR)</code>的值为（）。</p><p>选项：</p><p>• 4</p><p>• 5</p><p>• 6</p><p>• 8</p><h2 id="题目-2"><a href="#题目-2" class="headerlink" title="题目 2"></a>题目 2</h2><p>在C语言中，关于关键字<code>static</code>的说法，以下错误的是（）。</p><p>选项：</p><ol><li><p>在函数内，一个被声明为静态的变量，该变量在该函数第二次调用开始时值，等于该函数第一次调用结束时的值（仅考虑单线程调用）。</p></li><li><p>在一个C文件内（但在函数体外），一个被声明为静态的变量可以被该C文件内所用函数访问，但不能被该C文件外其它函数访问。</p></li><li><p>在一个C文件中，一个被声明为静态的函数只可被这一C文件的函数调用。</p></li><li><p>函数内定义的static变量，在函数第一次执行时被初始化。</p></li></ol><h2 id="题目-3"><a href="#题目-3" class="headerlink" title="题目 3"></a>题目 3</h2><p>请仔细阅读以下关于计算机网络和网络协议的描述，选择所有正确的选项。（多选）</p><p>选项：</p><ol><li><p>在TCP&#x2F;IP协议族中，TCP协议通过三次握手建立连接，确保数据的可靠传输，并且使用序列号和确认机制来实现这一功能。</p></li><li><p>IP协议是无连接的，它负责在网络中路由数据包，但不保证数据包的顺序传送或数据的完整性。</p></li><li><p>DNS协议在传输层工作，负责将域名解析为IP地址，使得用户可以通过更友好的域名来访问网络资源。</p></li><li><p>HTTP&#x2F;2是一种在HTTP&#x2F;1.1基础上改进的协议，它实现了多路复用，允许在同一个TCP连接上并行处理多个请求和响应。</p></li></ol><h2 id="题目-4"><a href="#题目-4" class="headerlink" title="题目 4"></a>题目 4</h2><p>Linux中的多路复用技术为高效处理多个I&#x2F;O事件提供了可能。以下关于Linux多路复用技术的说法，哪一项是正确的？（）</p><p>选项：</p><ol><li><p>使用epoll进行多路复用时，当某个文件描述符就绪，我们需要遍历所有注册的文件描述符来找到它就绪的具体事件。</p></li><li><p>在Linux中，多路复用技术最早是通过select系统调用来实现的。</p></li><li><p>Linux的多路复用技术不支持对多个文件描述符的同时监视。</p></li><li><p>多路复用技术只能应用于网络连接，不能应用于文件I&#x2F;O操作。</p></li></ol><h2 id="题目-5"><a href="#题目-5" class="headerlink" title="题目 5"></a>题目 5</h2><p>以下说法正确的是（）。</p><p>选项：</p><ol><li><p>宏定义只是单纯的文本替换，不会进行任何计算等。</p></li><li><p>sizeof是一个函数，运行时运算。</p></li><li><p>以下三个对a的声明，<code>char a[]; char a[100]; char *a;</code>是完全等价的，可以相互替换。</p></li><li><p>在1.c中定义有<code>char a[100];</code>，在2.c中<code>extern char a[];</code>，此时可以在2.c中可以使用<code>sizeof(a)</code>操作。</p></li></ol><h2 id="题目-6"><a href="#题目-6" class="headerlink" title="题目 6"></a>题目 6</h2><p>关于设计模式，以下哪个描述是错误的？（）</p><p>选项：</p><ol><li><p>装饰器模式允许用户在不改变对象的情况下，给对象添加新的职责（功能）。</p></li><li><p>观察者模式是一种让多个观察者同时监听某一主题对象，并在主题对象状态发生变化时自动收到通知的设计模式。</p></li><li><p>建造者模式主要用于构建复杂对象，它允许你在一个单独类中组合所有必要的逻辑来创建复杂对象，同时客户端代码又可以与对象的创建过程解耦。</p></li><li><p>单例模式确保一个类有一个或多个实例，并提供一个全局点来访问这些实例。</p></li></ol><h2 id="题目-7"><a href="#题目-7" class="headerlink" title="题目 7"></a>题目 7</h2><p>关于Java和C++的面向对象机制，以下说法不正确的是（）。</p><p>选项：</p><ol><li><p>Java使用垃圾回收机制来自动管理内存，而C++程序员通常需要手动管理内存，包括分配和释放。</p></li><li><p>在Java中，方法的重载是基于参数的数量和类型，而在C++中方法的重载还可以考虑返回类型。</p></li><li><p>Java中的接口允许定义方法但不包含实现，而C++中的抽象类（包含纯虚函数的类）有类似的作用，即定义一个可以由多个具体类实现的通用接口。</p></li><li><p>在Java中，可以通过<code>final</code>关键字来声明一个类不可被继承，而在C++中，无法直接声明一个类不可被继承，但可以通过设计模式和编程约定来间接实现。</p></li></ol><h2 id="题目-8"><a href="#题目-8" class="headerlink" title="题目 8"></a>题目 8</h2><p>关于多线程，以下哪个描述是正确的？（）</p><p>选项：</p><ol><li><p>多线程可以显著提高单核处理器的计算能力。</p></li><li><p>在多线程应用中，线程间只能通过共享内存来进行通信和数据交换。</p></li><li><p>相对于进程切换，线程切换通常具有较小的开销。</p></li><li><p>多线程程序中，所有线程共享同一个栈空间。</p></li></ol><h2 id="题目-9"><a href="#题目-9" class="headerlink" title="题目 9"></a>题目 9</h2><p>C语言中，下面表达式的值为4的为（）。</p><p>选项：</p><ol><li><p>11&#x2F;3</p></li><li><p>11.0&#x2F;3</p></li><li><p>(float)11&#x2F;3</p></li><li><p>(int)(11.0&#x2F;3+0.5)</p></li></ol><h2 id="题目-10"><a href="#题目-10" class="headerlink" title="题目 10"></a>题目 10</h2><p>请解释数据库事务中的“隔离级别”是什么，并列举至少两种常见的隔离级别。同时介绍不同的隔离级别可能带来的问题。</p><h2 id="题目-11"><a href="#题目-11" class="headerlink" title="题目 11"></a>题目 11</h2><p>请解释什么是分布式系统的一致性，并介绍几种常见的解决分布式系统一致性问题的策略，以及讨论在分布式系统中实现数据一致性面临哪些挑战。</p><h2 id="题目-12"><a href="#题目-12" class="headerlink" title="题目 12"></a>题目 12</h2><p>请解释数据库事务中的“隔离级别”是什么，并列举至少两种常见的隔离级别。同时介绍不同的隔离级别可能带来的问题。</p><h2 id="题目-13"><a href="#题目-13" class="headerlink" title="题目 13"></a>题目 13</h2><p>给你一个字符串s，如果该字符串的某个排列是回文串，则返回true；否则返回false。</p><p>示例1:<br>输入：s&#x3D;”code”<br>输出：false</p><p>示例2:<br>输入：s&#x3D;”aab”<br>输出：true</p><p>示例3:<br>输入：s&#x3D;”carerac”<br>输出：true</p><p>提示：<br>1&lt;&#x3D;s.length&lt;&#x3D;5000<br>s仅由小写英文字母组成</p><h1 id="笔试解析"><a href="#笔试解析" class="headerlink" title="笔试解析"></a>笔试解析</h1><h2 id="1-结构体大小计算"><a href="#1-结构体大小计算" class="headerlink" title="1.结构体大小计算"></a>1.结构体大小计算</h2><p>• 问题：给定一个结构体<code>FOOBAR</code>，包含一个<code>char</code>类型成员和一个<code>int</code>类型成员，在32位处理器上，<code>sizeof(FOOBAR)</code>的值是多少？</p><p>• 答案：8字节。因为<code>char</code>占用1字节，<code>int</code>占用4字节，加上3字节的填充，总共8字节。</p><h2 id="2-C语言中static关键字的使用"><a href="#2-C语言中static关键字的使用" class="headerlink" title="2.C语言中static关键字的使用"></a>2.C语言中<code>static</code>关键字的使用</h2><p>• 问题：关于C语言中<code>static</code>关键字的说法，哪个是错误的？</p><p>• 答案：所有选项都是正确的描述。可能题目本身存在问题。</p><h2 id="3-计算机网络和网络协议"><a href="#3-计算机网络和网络协议" class="headerlink" title="3.计算机网络和网络协议"></a>3.计算机网络和网络协议</h2><p>• 问题：选择所有正确的选项。</p><p>• 答案：正确的选项是：</p><p>• TCP协议通过三次握手建立连接，确保数据的可靠传输。</p><p>• IP协议是无连接的，负责在网络中路由数据包，但不保证数据包的顺序传送或数据的完整性。</p><p>• HTTP&#x2F;2实现了多路复用，允许在同一个TCP连接上并行处理多个请求和响应。</p><h2 id="4-Linux多路复用技术"><a href="#4-Linux多路复用技术" class="headerlink" title="4.Linux多路复用技术"></a>4.Linux多路复用技术</h2><p>• 问题：关于Linux多路复用技术的说法，哪一项是正确的？</p><p>• 答案：在Linux中，多路复用技术最早是通过select系统调用来实现的。</p><h2 id="5-C语言宏定义和类型"><a href="#5-C语言宏定义和类型" class="headerlink" title="5.C语言宏定义和类型"></a>5.C语言宏定义和类型</h2><p>• 问题：以下说法正确的是？</p><p>• 答案：在1.c中定义有<code>char a[100];</code>，在2.c中<code>extern char a[];</code>，此时可以在2.c中可以使用<code>sizeof(a)</code>操作。</p><h2 id="6-设计模式"><a href="#6-设计模式" class="headerlink" title="6.设计模式"></a>6.设计模式</h2><p>• 问题：关于设计模式，以下哪个描述是错误的？</p><p>• 答案：单例模式确保一个类有一个或多个实例，并提供一个全局点来访问这些实例。（这是错误的，单例模式确保一个类只有一个实例）</p><h2 id="7-Java和C-的面向对象机制"><a href="#7-Java和C-的面向对象机制" class="headerlink" title="7.Java和C++的面向对象机制"></a>7.Java和C++的面向对象机制</h2><p>• 问题：关于Java和C++的面向对象机制，以下说法不正确的是？</p><p>• 答案：在Java中，方法的重载是基于参数的数量和类型，而在C++中方法的重载还可以考虑返回类型。（这是错误的，C++中方法重载也不考虑返回类型）</p><h2 id="8-多线程"><a href="#8-多线程" class="headerlink" title="8.多线程"></a>8.多线程</h2><p>• 问题：关于多线程，以下哪个描述是正确的？</p><p>• 答案：相对于进程切换，线程切换通常具有较小的开销。</p><h2 id="9-C语言表达式求值"><a href="#9-C语言表达式求值" class="headerlink" title="9.C语言表达式求值"></a>9.C语言表达式求值</h2><p>• 问题：C语言中，下面表达式的值为4的为？</p><p>• 答案：<code>(int)(11.0/3+0.5)</code>。</p><h2 id="10-分布式系统数据一致性"><a href="#10-分布式系统数据一致性" class="headerlink" title="10.分布式系统数据一致性"></a>10.分布式系统数据一致性</h2><p>• 问题：解释什么是分布式系统的一致性，并介绍几种常见的解决分布式系统一致性问题的策略，以及讨论在分布式系统中实现数据一致性面临哪些挑战。</p><p>• 答案：分布式系统的一致性是指在系统的不同节点上，数据的副本保持同步和更新的状态。常见的一致性模型包括强一致性、最终一致性、因果一致性和读己之所写。解决策略包括分布式事务、数据复制、版本控制和共识算法。面临的挑战包括网络分区、并发冲突、数据复制延迟和故障恢复。</p><h2 id="11-数据库事务隔离级别"><a href="#11-数据库事务隔离级别" class="headerlink" title="11.数据库事务隔离级别"></a>11.数据库事务隔离级别</h2><p>• 问题：解释数据库事务中的“隔离级别”是什么，并列举至少两种常见的隔离级别。同时介绍不同的隔离级别可能带来的问题。</p><p>• 答案：隔离级别定义了事务在并发环境下如何被隔离，以防止数据的不一致性。常见的隔离级别包括读未提交、读已提交、可重复读和串行化。不同的隔离级别可能带来的问题包括脏读、不可重复读、幻读和性能问题。</p><h2 id="12-垃圾回收机制的编程语言"><a href="#12-垃圾回收机制的编程语言" class="headerlink" title="12.垃圾回收机制的编程语言"></a>12.垃圾回收机制的编程语言</h2><p>• 问题：列举你所知道的有垃圾回收机制的编程语言和没有垃圾回收机制的编程语言，并比较有无该机制的优劣。</p><p>• 答案：有垃圾回收机制的编程语言包括Java、Python和C#；没有垃圾回收机制的编程语言包括C和C++。有垃圾回收机制简化内存管理，减少内存泄漏，但可能引入性能开销；没有垃圾回收机制需要手动管理内存，增加了内存泄漏和指针错误的风险，但提供了更高的性能和资源控制。</p><h2 id="13-字符串回文排列"><a href="#13-字符串回文排列" class="headerlink" title="13.字符串回文排列"></a>13.字符串回文排列</h2><p>• 问题：给你一个字符串s，如果该字符串的某个排列是回文串，则返回true；否则返回false。</p><p>• 答案：使用字符计数，然后检查是否最多只有一个字符的计数是奇数。如果超过一个字符的计数是奇数，那么不可能存在回文排列。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 笔试 </tag>
            
            <tag> 招聘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>感悟(1)</title>
      <link href="/2025/01/05/%E6%84%9F%E6%82%9F-1/"/>
      <url>/2025/01/05/%E6%84%9F%E6%82%9F-1/</url>
      
        <content type="html"><![CDATA[<h1 id="关于延迟满足、海岛、音乐的思考与感悟"><a href="#关于延迟满足、海岛、音乐的思考与感悟" class="headerlink" title="关于延迟满足、海岛、音乐的思考与感悟"></a>关于延迟满足、海岛、音乐的思考与感悟</h1><h2 id="延迟满足"><a href="#延迟满足" class="headerlink" title="延迟满足"></a>延迟满足</h2><h3 id="延迟"><a href="#延迟" class="headerlink" title="延迟"></a>延迟</h3><p>自我观察，我有两个很明显的“不延迟”行为，一是打游戏，二是手冲，三是刷信息。首先是打游戏，细数下来，我用心沉浸进去的游戏并不多，我有特别仔细研究过打法的游戏吗？我有特别想了解剧情的游戏吗？我有获得超多感悟引发人生思考的游戏吗？想起来并不多，甚至可以说是没有。这感觉就是无意识的消磨时光，除了消磨时光，仿佛没有任何意义，但是，这段时光消磨过去了，我又在期待什么吗？会有突如其来的改变吗？会有恍若隔世的转变吗？会有某一个时间点突然的剧变吗？都没有。</p><p>特别是cs2、英雄联盟这类游戏，一局一局不断重复又略有不同和随机性的游戏，是浪费我光阴最多的游戏。它们的成瘾性体现在数百个小时，上千小时。我走进这段时光，出来仍是那个想要走进去的人，没有任何改变。对于这类游戏，我认为应该在我的人生中，对他们判处死刑。对于另一类剧情类的游戏，我认为当下的阶段，我无法心安理得的欣赏它们的剧情，可以暂时放在一边，等待他日机缘巧合再来判断。对于休闲收集类的游戏，比如少前2，我认为只要在可控制的时间范围内，是可以接受的。</p><p>对于手冲，这大概不是适合在这里提及的话题，毕竟我没有打算对这篇文章上锁，也不知道以后会不会有其他人看到。就不展开详细讨论了，但其影响之深远，时间持续之持久，应该和游戏不相上下，更是对生理和心理的双重污染，我认为这是最需要延迟的部分。的确很难克制，游戏尚可理解为无意识的消磨，但手冲我感觉已经是激素层面，已经产生了严重的戒断机制。这是需要延迟的重中之重。这是需要慢慢通过“满足”来引导的延迟内容。</p><p>最后是刷信息，内容庞杂，包括但不限于：1.qq、微信刷信息，生怕有人联系自己而错过，或是什么群的消息错过。但实际回想，几乎没有什么人来找我，我究竟在担心什么？我觉得可以对重要的人提个醒，找我就打电话，这样或许能有效抑制下刷qq、微信的频率。2.刷b站视频，这是类似游戏的无意义消磨，看上去了解很多信息，但实际上全是左耳朵进右耳朵出，很难留下有用的信息。我认为要找资料，就只能直接去搜索框输入要找的东西，不要去看推荐视频。3.小红书、论坛。小红书我认为同b站刷视频，毫无意义，建议有用的时候再下载然后去搜，使用完了就卸载。</p><h3 id="满足"><a href="#满足" class="headerlink" title="满足"></a>满足</h3><p>游戏上的满足，我觉得就收集向的勉强留下，也不能费时间，至于第二项，就留在心中吧，有感情的双向的行为远比一个人好。第三部分的满足，我觉得需要意识到重要的单独分出来，设置消息提醒就好，其他的不用去管，也没人会特意找自己，也不会产生什么突如其来的邂逅</p><h2 id="海岛"><a href="#海岛" class="headerlink" title="海岛"></a>海岛</h2><p>今年快23了，依然不知道自己到底想要什么，要做什么，要去哪里。但是考研失败回家这几天，我知道了我不要做什么，那就是留在遂宁，这样的生活我感觉真有点窒息了，一辈子被熟悉的亲朋好友禁锢，我宁愿没有人陪我，也不想天天被限制被侮辱。时时刻刻被当成小孩子一样管教。我第一段恋爱的失败，和这样的环境有很大的关系，甚至可以说，这样的环境导致我还不是一个完全独立有自主人格的成年人，还只是一个依靠父母生存的孩子罢了，更别说什么爱自己，这样的人没有资格也没有能力爱自己。所有独立的前提一定是要有独立生存的能力，不能自己挣钱的话，那人格独立就是个伪命题。</p><p>既然知道了自己不想要什么，那就可以理解现在的状况就是在一个新手村一样的海岛上，或许会恍恍惚惚地生活一辈子，但现在我意识到了，虽然没找到我要去的海岛，但我一定要离开这座海岛。无论游多久，什么时候才能上岸喘息，但一定一定要离开这座海岛，它太小又太压抑，有一些生存资源，但处处受制于人，没有真正意义上的自由可言。也无法在这座岛屿上成为一个真正独立自主的人。</p><h2 id="音乐"><a href="#音乐" class="headerlink" title="音乐"></a>音乐</h2><p>现阶段的我听音乐，没有目的性，也没有赏析的能力，无从感悟音乐结构，也不能体会其内涵，只是单纯地消磨时间，但就是这种无意识地消磨时间，我的人生走向了灰暗，走向了这座没有自由的岛屿。等我到了下座岛屿，希望我有真正自由的心情来体会这些歌曲吧</p><p>共勉，为了自由</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>方向</title>
      <link href="/2024/10/21/%E6%96%B9%E5%90%91/"/>
      <url>/2024/10/21/%E6%96%B9%E5%90%91/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="e15b794b985871f8be373fbc3a560a3f314a5aff8944e77ab716f43d7c88bff2">a9e30c21626359e888f88c58ad1760c419577100e57008cc3bd100da4c983bda76aec791cddcd67acb5583797a1dce557fd3309fd3526aec9db18dd738602b406a3de2d0d2437746f6122f2864081f2d515d2c1e458eff8d01c52718a200bea1d4994e6e893e6f60c479033f02690453826dba5444b2e85dc550714762b17a56c7eb87c1ff9e63b34611b21db658a0a54de3e93da6dca63293088c99fe56a54076ca48e38d7f6d4150bf8418747c82b33888c65ea76995b4f54781e9ca9639a049ff36c60a42819915f1c3af8867f6b5279acfdc59c25763f17d1b80fcb5bfbe4a2f0bcf7ca472619e657124aadf0ec9f96392b6521c7b2cc7ec37b170efddd406d41976bcb1a8899165dd17767787a43e9caf4f8dec232545668a3d98737b8dff8b5b8bfb325e9641a638283383011a16207788dfdb386dd8b425b7c67d8d8c34e52db46084d4cc55a6d0ad2b04fe1fee1c5e7e33077c32b8b0f3fa743ab451</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 自我思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我思考（五）</title>
      <link href="/2024/10/18/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2024/10/18/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-三思而后行（对抗无意识）"><a href="#1-三思而后行（对抗无意识）" class="headerlink" title="1.三思而后行（对抗无意识）"></a>1.三思而后行（对抗无意识）</h1><p>今天回顾自己的问题的时候，发现遭受的很多内耗和困难，实际上来源于自己的冲动，有一种激素控制身体，而这具身体不属于“我”的感觉。往小了说，比如手冲、贪玩、食欲等等，在那一瞬间我真的很想去做这事吗？</p><p>  我意识到，我应该在决定做一件事之前，问问自己这究竟是我想做这件事还是激素想做这件事。这件事情的利弊要分析清楚。</p><p>（ps：我在想这件事的时候，意识到了自己的另一个不好的习惯，也就是觉得“三思而后行”会不会显得太教条，太死板。这种奇怪的思维跳跃，我感觉来自以往看的一些作品，受其中一些人物的影响，实际上那些人物只是另一个极端罢了，我是冲动的极端，那些人是犹豫的极端，而我还没开始改变，还没有实施三思而后行，我的大脑就自动开始排斥，我觉得可能是觉得这是耗能的行为，也就是说，这思维跳跃本质上也是一种激素控制，根本就不是我在想，而是大脑觉得这么做会累就自动产生激素企图控制我不要实施这个思维进步，我讨厌我这一点。这激素感觉与我为敌一般，我承认习惯和下意识行为可以避免一些危险，但目前的情况来看，是我的行为逻辑大部分充满了无意识，缺乏理智的判断，已经是利大于弊，我必须意识到这一点）</p><h1 id="2-不要逃避问题"><a href="#2-不要逃避问题" class="headerlink" title="2.不要逃避问题"></a>2.不要逃避问题</h1><p>目前我对自己有一个认识，就是对于一件事，我不太想努力去尝试，而是选择摆烂，似乎这样在面对失败时我可以逃避说，我其实没有努力，但也还好不算太差。我不断又不断的拖延，颇有一种“相信后人的智慧”的感觉。</p><p>对于这方面我觉得一部分存在激素影响的下意识，也就是说已经习惯了摆烂，习惯了选择低耗能方式，“水往低处流”。然后还有一部分是因为，对于失败的恐惧？提前给自己找好退路？其实用脑子思考一下就能明白，我努力去做没有什么损失，即使考不上又如何呢？这努力的去做也是对自己的又一次打磨，始终是必原地打转好很多的。</p><p>对于这个方面，我有一个初步的改善计划，也是从其他人那里学习到的，就是先做一个简陋的东西，再不断完善，不要求一开始就尽善尽美，就不会有大的打击感和失落感。就像我开始写这篇思考前，想着东西好多，我真要写这么多吗，但现在往上一看，其实很快就写了这么多了，如果我今天不写这篇思考，损失真的太大。</p><h1 id="3-向外-对待他人"><a href="#3-向外-对待他人" class="headerlink" title="3.向外-对待他人"></a>3.向外-对待他人</h1><p>对于人际关系，我在想，我是不是缺爱。我那么渴求爱情、女朋友，我真的就这么需要吗？难道不结婚，不找女朋友我就要死要活吗？我是不是只是缺乏和人的深度交流？这方面我没有想到很好的解决办法，可以搁置慢慢寻找答案，目前我觉得应该做的就是完善自己，毕竟“达则兼济天下，穷则独善其身”。先处理好向内的事情，再解决向外的事情。</p><p>对于他人的认知，我现在有一个看法，就是大部分普通人思维应该不是有本质的差异，少部分先天因素，大部分则是后天的经历与学习共同造就，不存在高低优劣之说。人可能会有一个阶段性的思维爆发，ta不能理解我，我不能理解ta，很有可能只是思维不在同一个阶段，我不太认可思维不在同一个阶层这个说法，显得有些傲慢，人是需要成长的，每个人的思维处于不同阶段很正常，没必要贬低他人来彰显自己。</p><h1 id="4-结语"><a href="#4-结语" class="headerlink" title="4.结语"></a>4.结语</h1><p>综上，我为什么要思考这些，为什么要尝试去做这些，我有必要给自己怠惰低耗能的大脑和蛮横的激素系统一个交代，就四个字“利大于弊”，或者说以前的那套行事准则“弊大于利”了，我已经遭受严重的后果了，要知道反省，避免再次遭受痛苦</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我思考（四）</title>
      <link href="/2024/10/06/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/10/06/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="思考记录"><a href="#思考记录" class="headerlink" title="思考记录"></a>思考记录</h1><h2 id="1-情感的漂流"><a href="#1-情感的漂流" class="headerlink" title="1. 情感的漂流"></a>1. 情感的漂流</h2><ul><li><strong>背景</strong>：分手后，虽然已断开联系，但内心仍感到抑郁，常想再次联系前任。</li><li><strong>情感来源</strong>：怀念过去与未来的不确定性交织。</li></ul><h2 id="2-独立与依赖"><a href="#2-独立与依赖" class="headerlink" title="2. 独立与依赖"></a>2. 独立与依赖</h2><ul><li><strong>自我反思</strong>：作为独立个体，感到无法独自面对生活，是否意味着不成熟？</li><li><strong>关系中的不尊重</strong>：与前任的争吵源于对彼此的尊重缺失，反思人对人之间的价值寄托。</li></ul><h2 id="3-值得依赖的事物"><a href="#3-值得依赖的事物" class="headerlink" title="3. 值得依赖的事物"></a>3. 值得依赖的事物</h2><ul><li><strong>寻找新源泉</strong>：应在自然、文学、工作和宠物中寻找情感和价值，而非仅依赖他人。</li><li><strong>精神世界的生产与消费</strong>：<ul><li><strong>生产者</strong>：分享美丽风景、创造作品，持续生成精神能量，独立于他人。</li><li><strong>消费者</strong>：寄托情感和价值于他人，未曾思考如何参与生产。</li></ul></li></ul><h2 id="4-未来的方向"><a href="#4-未来的方向" class="headerlink" title="4. 未来的方向"></a>4. 未来的方向</h2><ul><li>记录思考，逐步探索创造精神能量的活动，迈向独立与充实。</li></ul><h3 id="探索创造精神能量的活动"><a href="#探索创造精神能量的活动" class="headerlink" title="探索创造精神能量的活动"></a>探索创造精神能量的活动</h3><ol><li><p><strong>自然探索</strong>：</p><ul><li>定期去户外，感受自然的美。可以尝试摄影或写生，记录下每次的经历。</li><li>参加徒步旅行或露营，增强与自然的联系。</li></ul></li><li><p><strong>创作艺术</strong>：</p><ul><li>写作：开始写日记、诗歌或短篇故事，表达你的情感和思考。</li><li>绘画或手工艺：尝试新的艺术形式，让自己的创造力流动。</li></ul></li><li><p><strong>阅读与学习</strong>：</p><ul><li>阅读文学作品、哲学书籍或自我成长的书籍，从中汲取灵感。</li><li>在线课程：学习一门新技能，拓宽视野，提升自我价值感。</li></ul></li><li><p><strong>与宠物的互动</strong>：</p><ul><li>养宠物或参与动物志愿活动，体验无条件的陪伴与爱。</li><li>观察动物的行为，反思其带给你的快乐与启发。</li></ul></li><li><p><strong>社会连接</strong>：</p><ul><li>加入兴趣小组或社区活动，寻找志同道合的人。</li><li>参与志愿者工作，帮助他人，同时获取成就感。</li></ul></li><li><p><strong>正念与冥想</strong>：</p><ul><li>定期进行冥想或正念练习，帮助你回归内心，提升自我意识。</li><li>关注当下，感受内心的情感波动，不再过度依赖他人。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实用主义思考</title>
      <link href="/2024/08/30/%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89%E6%80%9D%E8%80%83/"/>
      <url>/2024/08/30/%E5%AE%9E%E7%94%A8%E4%B8%BB%E4%B9%89%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<p>看了硬核的HeyMatt，心里得到了一些慰藉，特别是一期关于实用主义的思考引起了一些共鸣。<br>“两点之间直线线段最短”，在脑海中设定一个阶段性的终局，只需要朝着那个方向走就行了。目的设定好，就抛去杂念，径直地朝着目的前进即可。just do it。至于过程中的收获，则是看作附加物，这其中或许是痛苦或许是不情愿，又或者是苦尽甘来，都当做旁骛，而非目标，这样就能专心地去达成自己念想的终局。</p><p>评论1：我们每天有24张牌，我们每天需要考虑的就是，怎么把牌打出王炸，我们每周有七张牌，我们需要考虑的就是怎么将胜利最大化，我们每个月有30（31）张牌，我们需要考虑怎么保持优势，我们每年有12张牌，我们需要考虑怎么让自己的提升最大化……不管何时，我们都有一副牌，走出去，退回去，都取决于我们。每分每秒，我们都在进行决策，我们需要做的是将效率最大化，需要摒弃细枝末节，专注于当下。</p><p>评论2：比如说做自媒体，终局性画面是寻找1000个忠实粉丝，那么需要做出有价值的内容，来吸引10万粉。而在构建的过程中，不可避免的会有各种声音出现，会遭到冷遇。但这都没关系，我们是以终为始，以原则为中心来办事。</p><p>最后，我还有一个app想法，即创造一个实用主义类型的任务驱动型app，类似于打卡或是备忘录，但是是以任务的形式呈现，自己可以选择不同的体系，例如完成一个何种级别的自设定任务获得多少经验，然后有一个对应的升级体系，没有和其他人比较，只是给自己看，自己自嗨，例如修仙或是青铜王者这种，任务就可以设定成什么主线任务，支线任务，人生任务之类的。盈利的话，1是广告收入，2是用户自定义并可发布自己的创作，别人需要付费或每日签到得到金币，或者观看广告获得金币来购买他人创作的模板。app收取一定比例的费用</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>生活2024/7/7</title>
      <link href="/2024/07/07/%E7%94%9F%E6%B4%BB2024-7-7/"/>
      <url>/2024/07/07/%E7%94%9F%E6%B4%BB2024-7-7/</url>
      
        <content type="html"><![CDATA[<p>之前因为分手很难走出来，于是在小红书上发了第一篇感悟，感慨孤独之类的。过了一段时间很多人点赞留言之类的，但最让我印象深刻的还是今天。一个姐姐留言：“我听见了，你不是一个人，到处都是带着回忆不愿前进的人们，抱抱你，都会过去的”冥冥之中，我点进她的主页，愕然发现，她是一位坚强的抗癌女士。翻到底，从最开始的生活随录，到《顷刻间，到了人生转角》这篇博文，开始漫长的抗癌之路。一路看过来，她依然带着恐惧，带着害怕，担心辜负爱自己的人，也时不时发发心爱的小孩。然后，在今天，她鼓励了我，尽管我是一个陌生人，是一个自认为没有资格得到她鼓励的人。<br>   人生一辈子为何如此难过，我的痛苦顷刻间不足挂齿。愿你安好</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>（转）《花束般的恋爱》有感</title>
      <link href="/2024/06/22/%EF%BC%88%E8%BD%AC%EF%BC%89%E3%80%8A%E8%8A%B1%E6%9D%9F%E8%88%AC%E7%9A%84%E6%81%8B%E7%88%B1%E3%80%8B%E6%9C%89%E6%84%9F/"/>
      <url>/2024/06/22/%EF%BC%88%E8%BD%AC%EF%BC%89%E3%80%8A%E8%8A%B1%E6%9D%9F%E8%88%AC%E7%9A%84%E6%81%8B%E7%88%B1%E3%80%8B%E6%9C%89%E6%84%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="“二手经验”与“一手生活”之间的落差，是爱情消亡的重要原因之一"><a href="#“二手经验”与“一手生活”之间的落差，是爱情消亡的重要原因之一" class="headerlink" title="“二手经验”与“一手生活”之间的落差，是爱情消亡的重要原因之一"></a>“二手经验”与“一手生活”之间的落差，是爱情消亡的重要原因之一</h1><p>其实很多人想恋爱、甚至恋爱初期，<br>都不是为了恋爱，而是为了给自己分享欲、倾诉欲找一个出口。<br>想跟对方彻夜长谈，<br>分享童年、父母、旧时朋友、逝去的爱情。<br>展示自己的收藏、爱好，喜欢的艺术家，旅行中的突发事件。<br>得意时的奖章，悲伤时没人擦拭的眼泪，人群中忍住的抽泣和哽咽。<br>这些在日常生活里无法尽兴展示、收纳的秘密，是我们藏在衣橱深处的铁皮盒子。<br>我们期待把它交给一个有好感的、值得信任的人类同类。<br>仿佛交出之后，就不会孤单了，<br>同时，这个世界终于有一束光会注视着我们。不再被忽视，不再是配角，<br>可以做舞台中央的那个唯一了。</p><p>———这是极度单薄的「恋爱」，也是盲目的。</p><p>你期待那个人在得到了你交付的秘密（或者你们互换）之后，变得更与众不同，<br>你们因为握着彼此的铁皮盒子，这份爱情会更浓烈醇厚。</p><p>不是的。<br>倾诉与分享喷薄而出的时刻，常常是这份情感的最高峰了。<br>此后就下落，变成抛物线。</p><p>你永远应该收好自己的铁皮盒子。<br>那是你的财宝，你的秘密养分。<br>它是你一部分的「自我」，你可以在相爱&#x2F;共同生活的过程里，偶尔拿出一件往事跟对方闲聊咀嚼。<br>但它绝不是用来抵押&#x2F;交换一份感情的质物。</p><p>如果对方爱你，<br>打动ta的瞬间，应该是爱那个穿越了岁月生活、那个慢慢集满铁皮盒子的「人」。而不是这个人捧出的一只盒子。</p><p>何况，<br>残忍地说，人人都只想谈自己的事、展示自己的盒子，<br>其实没人想听别人的故事。</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 电影 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我思考（三）</title>
      <link href="/2024/06/12/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/06/12/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="2-绕石而行（绕石论-x2F-目的论）"><a href="#2-绕石而行（绕石论-x2F-目的论）" class="headerlink" title="2.绕石而行（绕石论&#x2F;目的论）"></a>2.绕石而行（绕石论&#x2F;目的论）</h2><h3 id="2-1-思考原型"><a href="#2-1-思考原型" class="headerlink" title="2.1 思考原型"></a>2.1 思考原型</h3><p>一个旅人在旅行时，发现前方的路被巨石阻挡，这时候有两个选择：1.生气咒骂，消耗精神  2.思考为什么巨石会挡在这，是否是因为这附近有山体滑坡等危险，是否是人为放置在这里，思考巨石出现在这里的原因。然后寻找对应的解决方案，比如绕开这个巨石。</p><h3 id="2-2-例子"><a href="#2-2-例子" class="headerlink" title="2.2 例子"></a>2.2 例子</h3><ul><li>阿德勒的目的论心理学有类似的地方，比如生气愤怒的情绪要从无意识的产生转变为意识到是自己潜意识的试图使用这种情绪来达成某种目的，意识到这一点之后，可以有效控制情绪，收放自如。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我思考（二）</title>
      <link href="/2024/06/09/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/06/09/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="1-利益交换（利益论）"><a href="#1-利益交换（利益论）" class="headerlink" title="1. 利益交换（利益论）"></a>1. 利益交换（利益论）</h2><p>实际上，以前我盲目的相信感情就是感情，不应该被利益所影响。但实际上，当我自己经历过一些事情后，才醒悟过来，关系（除亲人以外）的本质就是利益交换。</p><h3 id="1-1-例子"><a href="#1-1-例子" class="headerlink" title="1.1 例子"></a>1.1 例子</h3><ul><li>之前，我相信人会遇到对自己很好，接近无条件的爱的关系或情感。可能也是因为遇到第一任，意外与被动让我更信奉这个想法。但实际上关系破碎后，我一个多月的自我怀疑，情绪破碎，反复无常，对自己造成了巨大的心理创伤后，才意识到用利益论来解析这件事的本质。那就是，相信无条件爱的关系实际上对我有利，但对对方无利益，所以这不会是一个可持续的关系，迟早有一天会破碎</li><li>关于色情与自慰。这个话题中，对象不是我和别人，而是近期的我和长远的我之间的利益冲突。通过利益论可以得出，自慰可以给近期的我带来利益：1.消除短暂的压力 2.逃避困难 但实际上忽视了自慰这件事并不能给长远的我带来任何利益。戒色控欲可以给长远的我带来什么？分析可知：1.清晰健全的头脑，有助于我进一步完善自我，深度思考。 2.充沛的精神面貌，强健的体魄，有助于抵抗疾病，减少不幸。 这样来看，利益论实则清晰的指出了我应该选择的方向</li><li>而普通的人际交往，利益论的显而易见是更加明显的，加朋友的确是首先应该思考，我对对方有什么利益，如果没有答案，那很显然这段关系不会成立，哪怕成立也是无根之木，只能是一方强行支撑罢了。例如小j，她对我有情感价值，分享价值等等。我却无任何对她有利的地方，所以关系不可能长久，至于真诚，我觉得利益论来看，真诚实际上指的是我主动拿出利益等着对方来获取，在一个限定的时间内。真诚的度量那实际上就是这个限定的时间的长度。</li><li>关于挣钱，利益论的角度来看，一句话：想尽办法为对方提供利益是得到利益的开端。要想挣钱的话，思考的第一件事：我要从你这获取什么。第二件事：我能为你提供什么。第二件事的重要性大于第一件事，也更隐秘</li><li>关于休闲和娱乐。如果是有助于身心健康、自我思考的娱乐，那便是有利的，控制在合理时间内，符合利益论即可。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>商业模式思考</title>
      <link href="/2024/06/02/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83/"/>
      <url>/2024/06/02/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="商业模式，保姆级教学"><a href="#商业模式，保姆级教学" class="headerlink" title="商业模式，保姆级教学"></a>商业模式，保姆级教学</h1><h2 id="一、从零到全职收入的最快方法，即通过选择正确的商业模式来消除决策过程中的任何猜测，从而提高成功的机会。"><a href="#一、从零到全职收入的最快方法，即通过选择正确的商业模式来消除决策过程中的任何猜测，从而提高成功的机会。" class="headerlink" title="一、从零到全职收入的最快方法，即通过选择正确的商业模式来消除决策过程中的任何猜测，从而提高成功的机会。"></a>一、从零到全职收入的最快方法，即通过选择正确的商业模式来消除决策过程中的任何猜测，从而提高成功的机会。</h2><p>00:01 - 七步公式是实现快速全职收入的最快方法<br>02:22 - 选择适合你的商业模式，避免错误的商业中心<br>06:11 - 创业初学者应选择不需要产品开发的业务，如提供服务</p><h2 id="二、如何选择一个有利可图的服务，并将其作为自己的商业模式。服务应该具有可衡量的投资回报率，并且可以远程工作。"><a href="#二、如何选择一个有利可图的服务，并将其作为自己的商业模式。服务应该具有可衡量的投资回报率，并且可以远程工作。" class="headerlink" title="二、如何选择一个有利可图的服务，并将其作为自己的商业模式。服务应该具有可衡量的投资回报率，并且可以远程工作。"></a>二、如何选择一个有利可图的服务，并将其作为自己的商业模式。服务应该具有可衡量的投资回报率，并且可以远程工作。</h2><p>08:20 - 销售服务时，单位越少越好，不需要投资营销。<br>08:46 - 选择有利可图的服务，如每月1000-2500美元的收费。<br>10:28 - 提供投资回报的服务，如广告和电子邮件创作，收取高票价。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">从一个提供便利的服务者转变为ROI（投资回报）的提供者</span><br></pre></td></tr></table></figure><h2 id="三、如何通过冷外联获得客户的方法，需要考虑收入、利润率和产品单价等因素，并需要整理潜在客户的名单。"><a href="#三、如何通过冷外联获得客户的方法，需要考虑收入、利润率和产品单价等因素，并需要整理潜在客户的名单。" class="headerlink" title="三、如何通过冷外联获得客户的方法，需要考虑收入、利润率和产品单价等因素，并需要整理潜在客户的名单。"></a>三、如何通过冷外联获得客户的方法，需要考虑收入、利润率和产品单价等因素，并需要整理潜在客户的名单。</h2><p>16:42 - 创建备忘单，消除猜测，选择高收入利基市场<br>17:45 - 避免与创业和一个人经营的企业合作<br>18:51 - 选择高平均价格的企业合作，例如律师事务所和水池安装公司</p><h2 id="四、通过外联和会议的方式联系潜在客户，向他们展示服务并最终签约的过程，以及如何将其发展为固定的工作。"><a href="#四、通过外联和会议的方式联系潜在客户，向他们展示服务并最终签约的过程，以及如何将其发展为固定的工作。" class="headerlink" title="四、通过外联和会议的方式联系潜在客户，向他们展示服务并最终签约的过程，以及如何将其发展为固定的工作。"></a>四、通过外联和会议的方式联系潜在客户，向他们展示服务并最终签约的过程，以及如何将其发展为固定的工作。</h2><p>25:01 - 介绍商业模式和联系方式<br>26:01 - 减轻对方压力，展示如何帮助他们<br>28:49 - 需要更多客户和更高的月预聘金，但最重要的是创造一个简单的商业模式并执行它</p><h2 id="五、通过外包和承包商套利实现财务自由的方法。视频中详细介绍了如何寻找承包商、建立合作关系以及实现盈利的方法。"><a href="#五、通过外包和承包商套利实现财务自由的方法。视频中详细介绍了如何寻找承包商、建立合作关系以及实现盈利的方法。" class="headerlink" title="五、通过外包和承包商套利实现财务自由的方法。视频中详细介绍了如何寻找承包商、建立合作关系以及实现盈利的方法。"></a>五、通过外包和承包商套利实现财务自由的方法。视频中详细介绍了如何寻找承包商、建立合作关系以及实现盈利的方法。</h2><p>33:21 - 传统员工月底发工资，但承包商套利可以避免自掏腰包<br>34:33 - 雇佣有经验的承包商更便宜，且来自不同国家的员工更擅长他们所做的事情<br>37:16 - 通过在线销售服务实现财务自由，只需一张地图和一个安全网</p><h2 id="六、安全网的概念，并介绍了两个层次的安全网-学生群体和专家教练团队。这些安全网可以帮助学生在学习和外联中避免遇到困难。"><a href="#六、安全网的概念，并介绍了两个层次的安全网-学生群体和专家教练团队。这些安全网可以帮助学生在学习和外联中避免遇到困难。" class="headerlink" title="六、安全网的概念，并介绍了两个层次的安全网:学生群体和专家教练团队。这些安全网可以帮助学生在学习和外联中避免遇到困难。"></a>六、安全网的概念，并介绍了两个层次的安全网:学生群体和专家教练团队。这些安全网可以帮助学生在学习和外联中避免遇到困难。</h2><p>41:40 - 建立了安全网来避免学生从裂缝中掉下来<br>41:57 - 学生群体和社区内部可以分享旅程和互相帮助<br>42:54 - 专家教练团队提供销售和服务交付，每周电话工作方式</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 商业模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我思考（一）</title>
      <link href="/2024/06/02/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83/"/>
      <url>/2024/06/02/%E8%87%AA%E6%88%91%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h2 id="1-自我"><a href="#1-自我" class="headerlink" title="1. 自我"></a>1. 自我</h2><ul><li>注重自我管理与自律，主要从以下四个方面入手：<ol><li><strong>禁欲</strong>：节制欲望和需求，保持内心平静。</li><li><strong>不熬夜</strong>：规律作息，保持健康的生活习惯。</li><li><strong>健身运动</strong>：保持身体健康，通过运动增强体质。</li><li><strong>健康饮食</strong>：注重饮食健康，均衡营养。</li></ol></li></ul><h2 id="2-金钱"><a href="#2-金钱" class="headerlink" title="2. 金钱"></a>2. 金钱</h2><ul><li>制定合理的财务规划，重点在于以下三点：<ol><li><strong>资产配置</strong>：规划部分活动资金用于投资，如股市或国债，并学习相关投资知识。</li><li><strong>学习与机遇</strong>：理解服务与产品的关系，思考赚钱或副业的可能性，留心机会并加以把握。</li><li><strong>节流规划</strong>：仔细规划每一笔支出，合理分配资金，避免浪费。</li></ol></li></ul><h2 id="3-思想"><a href="#3-思想" class="headerlink" title="3. 思想"></a>3. 思想</h2><ul><li>关注内心世界和外部关系，从以下四方面提升思想层次：<ol><li><strong>正视自我</strong>：了解和接受自己，探寻内心真实的想法和需求。</li><li><strong>找到方向</strong>：明确未来的目标并为之努力，例如考研或找工作。</li><li><strong>吸纳思想</strong>：关注周围的美好事物，积极吸收正面的思想和观点。</li><li><strong>处理关系</strong>：妥善处理与他人的关系，学会情绪管理。</li></ol></li></ul><h2 id="4-其他思考"><a href="#4-其他思考" class="headerlink" title="4. 其他思考"></a>4. 其他思考</h2><ul><li>对于自身身份的深刻认知，意识到自己的独立性和处境的特殊性，例如：<ol><li><strong>自我认知</strong>：今天才真正意识到“我是我”。</li><li><strong>假设场景</strong>：假设自己生活在末世，没有后盾或避风港，这种思考有助于增强独立性和应对挑战的能力。</li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自我思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>03-HTML标签：排版标签</title>
      <link href="/2024/03/19/03-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE/"/>
      <url>/2024/03/19/03-HTML%E6%A0%87%E7%AD%BE%EF%BC%9A%E6%8E%92%E7%89%88%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-04-HTML标签：排版标签publish-true"><a href="#title-04-HTML标签：排版标签publish-true" class="headerlink" title="title: 04-HTML标签：排版标签publish: true"></a>title: 04-HTML标签：排版标签<br>publish: true</h2><p><ArticleTopAd></ArticleTopAd></p><h2 id="本文主要内容"><a href="#本文主要内容" class="headerlink" title="本文主要内容"></a>本文主要内容</h2><p>排版标签：</p><ul><li><p><code>&lt;h1&gt;</code></p></li><li><p><code>&lt;p&gt;</code></p></li><li><p><code>&lt;hr /&gt;</code></p></li><li><p><code>&lt;br /&gt;</code></p></li><li><p><code>&lt;div&gt;</code></p></li><li><p><code>&lt;span&gt;</code></p></li><li><p><code>&lt;center&gt;</code></p></li><li><p><code>&lt;pre&gt;</code></p></li></ul><p>下面来详细介绍一下排版标签。</p><h2 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h2><p>标题使用<code>&lt;h1&gt;</code>至<code>&lt;h6&gt;</code>标签进行定义。<code>&lt;h1&gt;</code>定义最大的标题，<code>&lt;h6&gt;</code>定义最小的标题。具有align属性，属性值可以是：left、center、right。</p><p>代码举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>H1：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>H3：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>H3：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span>H4：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span>H5：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>H6：千古壹号，永不止步<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>效果演示：</p><p><img src="http://img.smyhvae.com/20200402_1050.png"></p><h2 id="HTML-注释"><a href="#HTML-注释" class="headerlink" title="HTML 注释"></a>HTML 注释</h2><p>HTML 注释的格式如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 我是 html 注释  --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="段落标签-lt-p-gt"><a href="#段落标签-lt-p-gt" class="headerlink" title="段落标签&lt;p&gt;"></a>段落标签<code>&lt;p&gt;</code></h2><p>段落，是英语“paragraph“缩写。</p><p><strong>作用</strong>：可以把 HTML 文档分割为若干段落。在网页中如果要把文字有条理地显示出来，离不开段落标签。就如同我们平常写文章一样，整个网页也可以分为若干个段落。</p><p>代码举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is another paragraph<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>属性：</p><ul><li><code>align=&quot;属性值&quot;</code>：对齐方式。属性值包括left center right。</li></ul><p>属性举例：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html166440-1dcd2ad6e6353559.png" alt="Paste_Image.png"></p><p>HTML标签是分等级的，HTML将所有的标签分为两种：</p><ul><li><p><strong>文本级标签</strong>：p、span、a、b、i、u、em。文本级标签里只能放<strong>文字、图片、表单元素</strong>。（a标签里不能放a和input）</p></li><li><p><strong>容器级标签</strong>：div、h系列、li、dt、dd。容器级标签里可以放置任何东西。</p></li></ul><p>从学习p的第一天开始，就要牢牢记住：<strong>p标签是一个文本级标签，p里面只能放文字、图片、表单元素</strong>。其他的一律不能放。</p><p>错误写法：（尝试把 h 放到 p 里）</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">我是一个小段落</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我是一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>网页效果如下：</p><p><img src="http://img.smyhvae.com/20170630_1102.png"></p><p>上图显示，浏览器不允许你这么做，我们使用Chrome的F12审查元素发现，浏览器自己把p封闭掉了，不让你去包裹h1。</p><p>PS：Chrome浏览器是HTML5支持度最好的浏览器。提供了非常好的开发工具，非常适合我们开发人员使用。审查元素功能的快捷键是F12。</p><h2 id="水平线标签-lt-hr-gt"><a href="#水平线标签-lt-hr-gt" class="headerlink" title="水平线标签&lt;hr /&gt;"></a>水平线标签<code>&lt;hr /&gt;</code></h2><blockquote><p>horizontal 单词的发音：[ˌhɒrɪˈzɒntl]。</p></blockquote><p>水平分隔线（horizontal rule）可以在视觉上将文档分隔成各个部分。在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。</p><p>代码举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>自古情深留不住<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>总是套路得人心<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行效果：</p><p><img src="http://img.smyhvae.com/20200401_1930.png"></p><p>属性介绍：</p><ul><li><code>align=&quot;属性值&quot;</code>：设定线条置放位置。属性值可选择：left right center。</li><li><code>size=&quot;2&quot; </code>：设定线条粗细。以像素为单位，内定为2。</li><li><code>width=&quot;500&quot;</code>或<code>width=&quot;70%&quot;</code>：设定线条长度。可以是绝对值（单位是像素）或相对值。如果设置为相对值的话，内定为100%。</li><li><code>color=&quot;#0000FF&quot;</code>：设置线条颜色。</li><li><code>noshade</code>：不要阴影，即设定线条为平面显示。若没有这个属性则表明线条具阴影或立体。</li></ul><p>属性效果演示：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html_05.png" alt="Paste_Image.png"></p><h2 id="换行标签-lt-br-gt"><a href="#换行标签-lt-br-gt" class="headerlink" title="换行标签&lt;br /&gt;"></a>换行标签<code>&lt;br /&gt;</code></h2><p>如果希望某段文本强制换行显示，就需要使用换行标签。</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">This <span class="tag">&lt;<span class="name">br</span>/&gt;</span> is a para<span class="tag">&lt;<span class="name">br</span>/&gt;</span>graph with line breaks</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html03.png"></p><h2 id="lt-div-gt-和-lt-span-gt-标签"><a href="#lt-div-gt-和-lt-span-gt-标签" class="headerlink" title="&lt;div&gt;和&lt;span&gt;标签"></a><code>&lt;div&gt;</code>和<code>&lt;span&gt;</code>标签</h2><p>div和span是非常重要的标签，div的语义是division“分割”； span的语义就是span“范围、跨度”。想必你应该听说过“div + css”布局。</p><h3 id="div和span的介绍"><a href="#div和span的介绍" class="headerlink" title="div和span的介绍"></a>div和span的介绍</h3><ul><li><p><strong>div标签</strong>：可以把标签中的内容分割为独立的区块。必须单独占据一行。</p></li><li><p><strong>span标签</strong>：和div的作用一致，但不换行。</p></li></ul><p>代码举例：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html_08.png" alt="Paste_Image.png"></p><p>div标签的属性：</p><ul><li><code>align=&quot;属性值&quot;</code>：设置块儿的位置。属性值可选择：left、right、 center。</li></ul><h3 id="div和span的区别"><a href="#div和span的区别" class="headerlink" title="div和span的区别"></a>div和span的区别</h3><p><code>&lt;span&gt;</code>和<code>&lt;div&gt;</code>唯一的区别在于：<code>&lt;span&gt;</code>是不换行的，而<code>&lt;div&gt;</code>是换行的。</p><p>如果单独在网页中插入这两个元素，不会对页面产生任何的影响。这两个元素是专门为定义CSS样式而生的。或者说，DIV+CSS来实现各种样式。</p><p>div在浏览器中，默认是不会增加任何的效果的，但是语义变了，div中的所有元素是一个小区域。<br>div标签是一个<strong>容器级</strong>标签，里面什么都能放，甚至可以放div自己。</p><p>span也是表达“小区域、小跨度”的标签，但只是一个<strong>文本级</strong>的标签。<br>就是说，span里面只能放置文字、图片、表单元素。 span里面不能放p、h、ul、dl、ol、div。</p><p>span举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">简介简介简介简介简介简介简介简介</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>详细信息<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&quot;</span>&gt;</span>购买<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>div举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;header&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;logo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;nav&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;guanggao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;dongxi&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;footer&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们亲切地称这种模式叫做“<strong>div+css</strong>”：<strong>div标签负责布局、结构、分块，css负责样式</strong>。</p><h2 id="内容居中标签-lt-center-gt"><a href="#内容居中标签-lt-center-gt" class="headerlink" title="内容居中标签 &lt;center&gt;"></a>内容居中标签 <code>&lt;center&gt;</code></h2><p>此时center代表是一个标签，而不是一个属性值了。只要是在这个标签里面的内容，都会居于浏览器的中间。<br>效果演示：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html_06.png" alt="Paste_Image.png"></p><p>到了HTML5里面，center标签不建议使用，建议使用css布局来实现。</p><h2 id="预定义（预格式化）标签-lt-pre-gt"><a href="#预定义（预格式化）标签-lt-pre-gt" class="headerlink" title="预定义（预格式化）标签&lt;pre&gt;"></a>预定义（预格式化）标签<code>&lt;pre&gt;</code></h2><p>含义：将保留标签内部所有的空白字符(空格、换行符)，原封不动地输出结果（告诉浏览器不要忽略空格和空行）。</p><p>说明：真正排网页过程中，<code>&lt;pre&gt;</code>标签几乎用不着。<br>效果演示：</p><p><img src="http://img.smyhvae.com/2015-10-01-cnblogs_html_07.png" alt="Paste_Image.png"></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>02-初识HTML</title>
      <link href="/2024/03/19/02-%E5%88%9D%E8%AF%86HTML/"/>
      <url>/2024/03/19/02-%E5%88%9D%E8%AF%86HTML/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-03-初识HTMLpublish-true"><a href="#title-03-初识HTMLpublish-true" class="headerlink" title="title: 03-初识HTMLpublish: true"></a>title: 03-初识HTML<br>publish: true</h2><p><ArticleTopAd></ArticleTopAd></p><h2 id="编辑器相关"><a href="#编辑器相关" class="headerlink" title="编辑器相关"></a>编辑器相关</h2><p>前端开发的编辑器软件，我首先推荐 VS Code，其次推荐Sublime Text。</p><p>有人说 WebStorm 也不错？但真实情况是，自从VS Code 问世之后，用 WebStorm 的人越来越少了。</p><p>PS：文件的后缀名不能决定文件格式，只能决定打开文件打开的方式。</p><h3 id="VS-Code-的使用"><a href="#VS-Code-的使用" class="headerlink" title="VS Code 的使用"></a>VS Code 的使用</h3><p>详情请移步至：<a href="https://github.com/qianguyihao/Web/blob/master/00-%E5%89%8D%E7%AB%AF%E5%B7%A5%E5%85%B7/01-VS%20Code%E7%9A%84%E4%BD%BF%E7%94%A8.md">第一次使用VS Code时你应该知道的一切配置</a></p><h3 id="Sublime-Text-的使用"><a href="#Sublime-Text-的使用" class="headerlink" title="Sublime Text 的使用"></a>Sublime Text 的使用</h3><p>详情请移步至：<a href="https://github.com/qianguyihao/Mac/blob/master/03-%E5%85%A8%E5%B9%B3%E5%8F%B0%E8%BD%AF%E4%BB%B6/Sublime%20Text%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7.md">Sublime Text使用技巧</a></p><h2 id="HTML的概述"><a href="#HTML的概述" class="headerlink" title="HTML的概述"></a>HTML的概述</h2><h3 id="HTML的概念"><a href="#HTML的概念" class="headerlink" title="HTML的概念"></a>HTML的概念</h3><p><strong>HTML</strong> 全称为 HyperText Markup Language，译为<font color=#0000ff><strong>超文本标记语言</strong></font>。</p><p>HTML 不是一种编程语言，是一种描述性的<strong>标记语言</strong>。</p><p><strong>作用</strong>：HTML是负责描述文档<strong>语义</strong>的语言。</p><h3 id="概念：超文本"><a href="#概念：超文本" class="headerlink" title="概念：超文本"></a>概念：超文本</h3><p>所谓的超文本，有两层含义：</p><p>（1）图片、音频、视频、动画、多媒体等内容，被称为超文本，因为它们超出了文本的限制。</p><p>（2）不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件进行连接。即：超级链接文本。</p><h3 id="概念：标记语言"><a href="#概念：标记语言" class="headerlink" title="概念：标记语言"></a>概念：标记语言</h3><p>HTML 不是一种编程语言，是一种描述性的<strong>标记语言</strong>。这主要有两层含义：</p><p>（1）<strong>标记语言是一套标记标签</strong>。比如：标签<code>&lt;a&gt;</code>表示超链接、标签<code>&lt;img&gt;</code>表示图片、标签<code>&lt;h1&gt;</code>表示一级标题等等，它们都是属于 HTML 标签。</p><p>说的通俗一点就是：网页是由网页元素组成的，这些元素是由 HTML 标签描述出来，然后通过浏览器解析，就可以显示给用户看了。</p><p>（2）编程语言是有编译过程的，而标记语言没有编译过程，HTML标签是直接由浏览器解析执行。</p><h3 id="HTML是负责描述文档语义的语言"><a href="#HTML是负责描述文档语义的语言" class="headerlink" title="HTML是负责描述文档语义的语言"></a>HTML是负责描述文档语义的语言</h3><p>HTML 格式的文件是一个纯本文文件（就是用txt文件改名而成），用一些标签来描述语义，这些标签在浏览器页面上是无法直观看到的，所以称之为“超文本标记语言”。</p><p>接下来，我们需要学习 HTML 中的很多“标签对儿”，这些“标签对儿”能够给文本不同的语义。</p><p>比如，面试的时候问你，<code>&lt;h1&gt;</code> 标签有什么作用？</p><ul><li>正确答案：给文本增加主标题的语义。</li><li>错误答案：给文字加粗、加黑、变大。</li></ul><p>关乎“语义”的更深刻理解，等接下来我们学习了各种标签，就明白了。</p><h2 id="HTML的历史"><a href="#HTML的历史" class="headerlink" title="HTML的历史"></a>HTML的历史</h2><p><img src="http://img.smyhvae.com/20151001_1001.png" alt="html中标签发展趋势"></p><p>其中，我们专门来对XHTML做一个介绍。</p><p><strong>XHTML介绍：</strong><br>XHTML：Extensible Hypertext Markup Language，可扩展超文本标注语言。<br>XHTML的主要目的是为了<font color="blue"><strong>取代HTML</strong></font>，也可以理解为HTML的升级版。<br>HTML的标记书写很不规范，会造成其它的设备(ipad、手机、电视等)无法正常显示。<br>XHTML与HTML4.0的标记基本上一样。<br>XHTML是<font color="blue"><strong>严格的、纯净的</strong></font>HTML。</p><p>我们稍后将对XHTML的编写规范进行介绍。</p><h2 id="HTML的专有名词"><a href="#HTML的专有名词" class="headerlink" title="HTML的专有名词"></a>HTML的专有名词</h2><ul><li>网页 ：由各种标记组成的一个页面就叫网页。</li><li>主页(首页) : 一个网站的起始页面或者导航页面。</li><li>标记：  比如<code>&lt;p&gt;</code>称为开始标记 ，<code>&lt;/p&gt;</code>称为结束标记，也叫标签。每个标签都规定好了特殊的含义。</li><li>元素：比如<code>&lt;p&gt;内容&lt;/p&gt;</code>称为元素.</li><li>属性：给每一个标签所做的辅助信息。</li><li>XHTML：符合XML语法标准的HTML。</li><li>DHTML：dynamic，动态的。<code>javascript + css + html</code>合起来的页面就是一个 DHTML。</li><li>HTTP：超文本传输协议。用来规定客户端浏览器和服务端交互时数据的一个格式。SMTP：邮件传输协议，FTP：文件传输协议。</li></ul><h2 id="书写第一个-HTML-页面"><a href="#书写第一个-HTML-页面" class="headerlink" title="书写第一个 HTML 页面"></a>书写第一个 HTML 页面</h2><p>我们打开 VS Code 软件，新建一个文件，名叫<code>test.html</code>（注意，文件名是<code>test</code>，后缀名是<code>html</code>），保存到本地。</p><p>紧接着，在文件里，输入<code>html:5</code>，然后按一下键盘上的<code>Tab</code>键，就可以自动生成如下内容：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的内容，就是 html 页面的骨架。我们在此基础之上，新增几个标签，完整代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是三级标题<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.jd.com&quot;</span>&gt;</span>我是超链接，可以点击一下<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>标签写完之后，我们用 chrome 浏览器打开上面这个<code>test.html</code>文件，看看页面效果：</p><p>到此，第一个简单的 HTML 页面就写完了。是不是很有成就感？</p><h2 id="HTML结构详解"><a href="#HTML结构详解" class="headerlink" title="HTML结构详解"></a>HTML结构详解</h2><p>HTML标签通常是成对出现的（<font color="blue"><strong>双边标记</strong></font>），比如 <code>&lt;div&gt;</code> 和 <code>&lt;/div&gt;</code>；也有少部分单标签（<font color="blue"><strong>单边标记</strong></font>），如：<code>&lt;br /&gt;</code>、<code>&lt;hr /&gt;</code>和<code>&lt;img src=&quot;images/1.jpg&quot; /&gt;</code>等。</p><p>属性与标记之间、各属性之间需要以空格隔开。属性值以双引号括起来。</p><h4 id="html骨架标签分类"><a href="#html骨架标签分类" class="headerlink" title="html骨架标签分类"></a>html骨架标签分类</h4><table><thead><tr><th>标签名</th><th align="center">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td><code>&lt;html&gt;&lt;/html&gt;</code></td><td align="center">HTML标签</td><td align="left">页面中最大的标签，我们成为根标签</td></tr><tr><td><code>&lt;head&gt;&lt;/head&gt;</code></td><td align="center">文档的头部</td><td align="left">注意在head标签中我们必须要设置的标签是title</td></tr><tr><td><code>&lt;title&gt;&lt;/title&gt;</code></td><td align="center">文档的标题</td><td align="left">让页面拥有一个属于自己的网页标题</td></tr><tr><td><code>&lt;body&gt;&lt;/body&gt;</code></td><td align="center">文档的主体</td><td align="left">元素包含文档的所有内容，页面内容 基本都是放到body里面的</td></tr></tbody></table><h3 id="快速生成-html-的骨架"><a href="#快速生成-html-的骨架" class="headerlink" title="快速生成 html 的骨架"></a>快速生成 html 的骨架</h3><p><strong>方式1</strong>：在 VS Code 中新建 html 文件，输入<code>html:5</code>，按 <code>Tab</code>键后，自动生成的代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>方式2</strong>：在Sublime Text中安装<code>Emmet</code>插件。新建html文件，输入<code>html:5</code>，按<code>Tab</code>键后，自动生成的代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>方式3</strong>：在Sublime Text中安装<code>Emmet</code>插件。新建html文件，输入<code>html:xt</code>，按<code>Tab</code>键后，自动生成的代码如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span> <span class="keyword">PUBLIC</span> <span class="string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span> <span class="string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="attr">xml:lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的方式2和方式3中，我们会发现，第一行的内容有些不太一样，这就是我们接下来要讲的<strong>文档声明头</strong>。</p><h3 id="1、文档声明头"><a href="#1、文档声明头" class="headerlink" title="1、文档声明头"></a>1、文档声明头</h3><p>任何一个标准的HTML页面，第一行一定是一个以<code>&lt;!DOCTYPE ……&gt;</code>开头的语句。这一行，就是文档声明头，即 DocType Declaration，简称DTD。</p><p><strong>DTD可告知浏览器文档使用哪种 HTML 或 XHTML 规范</strong>。</p><h4 id="HTML4-01有哪些规范呢？"><a href="#HTML4-01有哪些规范呢？" class="headerlink" title="HTML4.01有哪些规范呢？"></a>HTML4.01有哪些规范呢？</h4><p><strong>HTML4.01</strong>这个版本是IE6开始兼容的。<strong>HTML5是IE9开始兼容的</strong>。如今，手机、移动端的网页，就可以使用HTML5了，因为其兼容性更高。</p><p>说个题外话，html1 至 html3 是美国军方以及高等研究所用的，并未对外公开。</p><p>HTML4.01里面有两大种规范，每大种规范里面又各有3种小规范。所以一共6种规范（见下图）。</p><p>HTML4.01里面规定了<strong>普通</strong>和<strong>XHTML</strong>两大种规范。HTML觉得自己有一些规定不严谨，比如，标签是否可以用大写字母呢？<code>&lt;H1&gt;&lt;/H1&gt;</code>所以，HTML就觉得，把一些规范严格的标准，又制定了一个XHTML1.0。在XHTML中的字母X，表示“严格的”。</p><p>总结一下，HTML4.01一共有6种DTD。说白了，HTML的第一行语句一共有6种情况：</p><p><img src="http://img.smyhvae.com/20170629_1600.png"></p><p>下面对上图中的三种小规范进行解释：</p><p><strong>strict</strong>：</p><p>表示“严格的”，这种模式里面的要求更为严格。这种严格体现在哪里？有一些标签不能使用。<br>比如，u标签，就是给一个本文加下划线，但是这和HTML的本质有冲突，因为HTML最好是只负责语义，不要负责样式，而u这个下划线是样式。所以，在strict中是不能使用u标签的。</p><p>那怎么给文本增加下划线呢？今后将使用css属性来解决。</p><p>XHTML1.0更为严格，因为这个体系本身规定比如标签必须是小写字母、必须严格闭合标签、必须使用引号引起属性等等。</p><p><strong>Transitional</strong>：表示“普通的”，这种模式就是没有一些别的规范。</p><p><strong>Frameset</strong>：表示“框架”，在框架的页面使用。</p><p>在sublime输入的html:xt，x表示XHTML，t表示transitional。</p><p>在HTML5中极大的简化了DTD，也就是说HTML5中就没有XHTML了。HTML5的DTD（文档声明头）如下：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure><h3 id="2、页面语言-lang"><a href="#2、页面语言-lang" class="headerlink" title="2、页面语言 lang"></a>2、页面语言 <code>lang</code></h3><p>下面这行标签，用于指定页面的语言类型：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>最常见的语言类型有两种：</p><ul><li><p>en：定义页面语言为英语。</p></li><li><p>zh-CN：定义页面语言为中文。</p></li></ul><h3 id="3、头标签-head"><a href="#3、头标签-head" class="headerlink" title="3、头标签 head"></a>3、头标签 <code>head</code></h3><h4 id="html5-的比较完整的骨架："><a href="#html5-的比较完整的骨架：" class="headerlink" title="html5 的比较完整的骨架："></a>html5 的比较完整的骨架：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">content</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;厉害很厉害&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>面试题：</p><ul><li>问：网页的head标签里面，表示的是页面的配置，有什么配置？</li><li>答：字符集、关键词、页面描述、页面标题、IE适配、视口、iPhone小图标等等。</li></ul><p>头标签内部的常见标签如下：</p><ul><li><code>&lt;title&gt;</code>：指定整个网页的标题，在浏览器最上方显示。</li><li><code>&lt;base&gt;</code>：为页面上的所有链接规定默认地址或默认目标。</li><li><code>&lt;meta&gt;</code>：提供有关页面的基本信息</li><li><code>&lt;body&gt;</code>：用于定义HTML文档所要显示的内容，也称为主体标签。我们所写的代码必须放在此标签內。</li><li><code>&lt;link&gt;</code>：定义文档与外部资源的关系。</li></ul><p><strong>meta 标签</strong>：</p><p>meta表示“元”。“元”配置，就是表示基本的配置项目。</p><p>常见的几种 meta 标签如下：</p><p>（1）字符集 charset：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html;charset=UTF-8&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>字符集用meta标签中的<code>charset</code>定义，charset就是character set（即“字符集”），即<strong>网页的编码方式</strong>。</p><p><strong>字符集</strong>(Character set)是多个字符的集合。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。</p><p>上面这行代码非常关键， 是必须要写的代码，否则可能导致乱码。比如你保存的时候，meta写的和声明的不匹配，那么浏览器就是乱码。</p><p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312等。关于“编码方式”，我们在下一段会详细介绍。</p><p>（2）视口 viewport：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>width=device-width</code> ：表示视口宽度等于屏幕宽度。</p><p>viewport 这个知识点，初学者还比较难理解，以后学 Web 移动端的时候会用到。</p><p>（3）定义“关键词”：</p><p>举例如下：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Keywords&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网易,邮箱,游戏,新闻,体育,娱乐,女性,亚运,论坛,短信&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这些关键词，就是告诉搜索引擎，这个网页是干嘛的，能够提高搜索命中率。让别人能够找到你，搜索到你。</p><p>（4）定义“页面描述”：</p><p>meta除了可以设置字符集，还可以设置关键字和页面描述。</p><p>只要设置Description页面描述，那么百度搜索结果，就能够显示这些语句，这个技术叫做<strong>SEO</strong>（search engine optimization，搜索引擎优化）。</p><p>设置页面描述的举例：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;Description&quot;</span> <span class="attr">content</span>=<span class="string">&quot;网易是中国领先的互联网技术公司，为用户提供免费邮箱、游戏、搜索引擎服务，开设新闻、娱乐、体育等30多个内容频道，及博客、视频、论坛等互动交流，网聚人的力量。&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="http://img.smyhvae.com/20170629_1743.png"></p><p>上面的几种<code>&lt;meta&gt;</code>标签都不用记，但是另外还有一个<code>&lt;meta&gt;</code>标签是需要记住的：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;refresh&quot;</span> <span class="attr">content</span>=<span class="string">&quot;3;http://www.baidu.com&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面这个标签的意思是说，3秒之后，自动跳转到百度页面。</p><p><strong>title 标签</strong>:</p><p>用于设置网页标题：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>网页的标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure><p>title标签也是有助于SEO搜索引擎优化的。</p><p><strong>base标签</strong>：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;/&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>base 标签用于指定基础的路径。指定之后，所有的 a 链接都是以这个路径为基准。</p><h3 id="4、-lt-body-gt-标签"><a href="#4、-lt-body-gt-标签" class="headerlink" title="4、&lt;body&gt;标签"></a>4、<code>&lt;body&gt;</code>标签</h3><p><code>&lt;body&gt;</code>标签的属性有：</p><ul><li><code>bgcolor</code>：设置整个网页的背景颜色。</li><li><code>background</code>：设置整个网页的背景图片。</li><li><code>text</code>：设置网页中的文本颜色。</li><li><code>leftmargin</code>：网页的左边距。IE浏览器默认是8个像素。</li><li><code>topmargin</code>：网页的上边距。</li><li><code>rightmargin</code>：网页的右边距。</li><li><code>bottommargin</code>：网页的下边距。</li></ul><p><code>&lt;body&gt;</code>标签另外还有一些属性，这里用个例子来解释：</p><p><img src="http://img.smyhvae.com/2015-10-02-cnblogs_html_39.png"></p><p>上方代码中，当我们对<code>点我点我</code>这几个字使用超链时，<code>link</code>属性表示默认显示的颜色、<code>alink</code>属性表示鼠标点击但是还没有松开时的颜色、<code>vlink</code>属性表示点击完成之后显示的颜色。效果如下：</p><p><img src="http://img.smyhvae.com/2015-10-02-cnblogs_html_05.gif"></p><h2 id="计算机编码介绍"><a href="#计算机编码介绍" class="headerlink" title="计算机编码介绍"></a>计算机编码介绍</h2><p>计算机，不能直接存储文字，存储的是编码。</p><p>计算机只能处理二进制的数据，其它数据，比如：0-9、a-z、A-Z，这些字符，我们可以定义一套规则来表示。假如：A用110表示，B用111表示等。</p><p><strong>ASCII码：</strong><br>美国发布的，用1个字节(8位二进制)来表示一个字符，共可以表示2^8&#x3D;256个字符。<br>    美国的国家语言是英语，只要能表示0-9、a-z、A-Z、特殊符号。</p><p><strong>ANSI编码：</strong><br><strong>每个国家为了显示本国的语言，都对ASCII码进行了扩展</strong>。用2个字节(16位二进制)来表示一个汉字，共可以表示2^16＝65536个汉字。例如：<br>中国的ANSI编码是GB2312编码(简体)，对6763汉字进行编码，含600多特殊字符。另外还有GBK(简体)。<br>日本的ANSI编码是JIS编码。<br>台湾的ANSI编码是BIG5编码（繁体）。</p><p><strong>GBK：</strong><br>对GB2312进行了扩展，用来显示罕见的、古汉语的汉字。现在已经收录了2.1万左右。并提供了1890个汉字码位。K的含义就是“扩展”。</p><p><strong>Unicode编码(统一编码)：</strong><br>用4个字节(32位二进制)来表示一个字符，想法不错，但效率太低。例如，字母A用ASCII表示的话一个字节就够，可用Unicode编码的话，得用4个字节表示，造成了空间的极大浪费。A的Unicode编码是0000 0000 0000 0000 0000 0000 0100 0000</p><p><strong>UTF-8(Unicode Transform Format)编码：</strong><br>根据字符的不同，选择其编码的长度。比如：一个字符A用1个字节表示，一个汉字用2个字节表示。</p><p>毫无疑问，开发中，都用<strong>UTF-8</strong>编码吧，准没错。</p><p><strong>中文能够使用的字符集两种：</strong></p><ul><li><p>第一种：UTF-8。UTF-8是国际通用字库，里面涵盖了所有地球上所有人类的语言文字，比如阿拉伯文、汉语、鸟语……</p></li><li><p>第二种：GBK（对GB2312进行了扩展）。gb2312 是国标，是中国的字库，里面<strong>仅</strong>涵盖了汉字和一些常用外文，比如日文片假名，和常见的符号。</p></li></ul><p>字库规模：  UTF-8（字很全） &gt; gb2312（只有汉字）</p><p><strong>重点1：避免乱码</strong></p><p>我们用meta标签声明的当前这个html文档的字库，一定要和保存的文件编码类型一样，否则乱码（重点）。</p><p>拿 sublime编辑器举例，当我们不设置的时候，sublime默认类型就是UTF-8。而一旦更改为gb2312的时候，就一定要记得设置一下sublime的保存类型： <code>文件→ set File Encoding to → Chinese Simplified(GBK)</code>。VS Code 的道理一样。</p><p><strong>重点2：UTF-8和gb2312的比较</strong></p><p>保存大小：UTF-8（更臃肿、加载更慢） &gt; gb2312 （更小巧，加载更快）</p><p>总结：</p><ul><li>UTF-8：字多，有各种国家的语言，但是保存尺寸大，文件臃肿；</li><li>gb2312：字少，只用中文和少数外语和符号，但是尺寸小，文件小巧。</li></ul><p>列出2个使用情形：</p><p>1） 你们公司是做日本动漫的，经常出现一些日语动漫的名字，网页要使用UTF-8。如果用gb2312将无法显示日语。<br>2） 你们公司就是中文网页，极度的追求网页的显示速度，要使用gb2312。如果使用UTF-8将每个汉字多一个byte，所以5000个汉字，多5kb。</p><p>我们亲测：</p><ul><li>qq网、网易、搜狐都是使用gb2312。这些公司，都追求显示速度。</li><li>新华网藏语频道，使用的是UTF-8，保证字符集的数量。</li></ul><p>我们是怎么查看网页的编码方式的呢？在浏览器中打开网页，右键，选择“查看网页源代码”，找到meta标签中的charset属性即可。</p><p>那么，我们为什么可以查看网页的源代码呢？因为这个打开的html网页已经存到我的临时文件夹里了，临时文件夹里的html是纯文本文件，纯文本文件自然可以查看网页的源代码。</p><h2 id="HTML的规范"><a href="#HTML的规范" class="headerlink" title="HTML的规范"></a>HTML的规范</h2><ul><li>HTML不区分大小写，但HTML的标签名、类名、标签属性、大部分属性值建议统一用小写。</li><li>HTML页面的后缀名是html或者htm(有一些系统不支持后缀名长度超过3个字符，比如dos系统)</li></ul><h3 id="1、编写XHTML的规范："><a href="#1、编写XHTML的规范：" class="headerlink" title="1、编写XHTML的规范："></a>1、编写XHTML的规范：</h3><p>（1）所有标记元素都要正确的嵌套，不能交叉嵌套。正确写法举例：<code>&lt;h1&gt;&lt;font&gt;&lt;/font&gt;&lt;/h1&gt;</code></p><p>（2）所有的标记都必须小写。</p><p>（3）所有的标签都必须闭合。</p><ul><li><p>双标签：<code>&lt;span&gt;&lt;/span&gt;</code></p></li><li><p>单标签：<code>&lt;br&gt;</code> 建议写成 <code>&lt;br /&gt;</code>   <code>&lt;hr&gt;</code> 建议转成 <code>&lt;hr /&gt;</code>，还有<code>&lt;img src=“URL” /&gt;</code></p></li></ul><p>（4）所有的属性值必须加引号。<code>&lt;font  color=&quot;red&quot;&gt;&lt;/font&gt;</code></p><p>（5）所有的属性必须有值。<code>&lt;hr noshade=&quot;noshade&quot;&gt;</code>、<code>&lt;input  type=&quot;radio&quot; checked=&quot;checked&quot; /&gt;</code></p><p>（6）XHTML文档开头必须要有DTD文档类型定义。</p><h3 id="2、HTML的基本语法特性"><a href="#2、HTML的基本语法特性" class="headerlink" title="2、HTML的基本语法特性"></a>2、HTML的基本语法特性</h3><h4 id="（1）HTML对换行不敏感，对tab不敏感"><a href="#（1）HTML对换行不敏感，对tab不敏感" class="headerlink" title="（1）HTML对换行不敏感，对tab不敏感"></a>（1）HTML对换行不敏感，对tab不敏感</h4><p>HTML只在乎标签的嵌套结构，嵌套的关系。谁嵌套了谁，谁被谁嵌套了，和换行、tab无关。换不换行、tab不tab，都不影响页面的结构。</p><p>也就是说，HTML不是依靠缩进来表示嵌套的，而是看标签的嵌套关系。但是，我们发现有良好的缩进，代码更易读。建议大家都正确缩进标签。</p><p>百度为了追求极致的显示速度，所有HTML标签都没有换行、都没有缩进（tab），HTML和换不换行无关，标签的层次依然清晰，只不过程序员不可读了。如下图所示：</p><p><img src="http://img.smyhvae.com/20170629_2226.png"></p><h4 id="（2）空白折叠现象"><a href="#（2）空白折叠现象" class="headerlink" title="（2）空白折叠现象"></a>（2）空白折叠现象</h4><p>HTML中所有的<strong>文字之间</strong>，如果有空格、换行、tab都将被折叠为一个空格显示。</p><p>举例如下：</p><p><img src="http://img.smyhvae.com/20170629_2230.jpg"></p><h4 id="（3）标签要严格封闭"><a href="#（3）标签要严格封闭" class="headerlink" title="（3）标签要严格封闭"></a>（3）标签要严格封闭</h4><p>标签不封闭的结果是灾难性的。</p><p>标签不封闭的举例如下：</p><p><img src="http://img.smyhvae.com/20170629_2245.jpg"></p>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>01-认识Web和Web标准</title>
      <link href="/2024/03/19/01-%E8%AE%A4%E8%AF%86Web%E5%92%8CWeb%E6%A0%87%E5%87%86/"/>
      <url>/2024/03/19/01-%E8%AE%A4%E8%AF%86Web%E5%92%8CWeb%E6%A0%87%E5%87%86/</url>
      
        <content type="html"><![CDATA[<hr><h2 id="title-01-认识Web和Web标准publish-true"><a href="#title-01-认识Web和Web标准publish-true" class="headerlink" title="title: 01-认识Web和Web标准publish: true"></a>title: 01-认识Web和Web标准<br>publish: true</h2><p><ArticleTopAd></ArticleTopAd></p><h2 id="Web、网页、浏览器"><a href="#Web、网页、浏览器" class="headerlink" title="Web、网页、浏览器"></a>Web、网页、浏览器</h2><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web（World Wide Web）即全球广域网，也称为万维网。</p><p>我们常说的<code>Web端</code>就是网页端。</p><h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p><strong>网页是构成网站的基本元素</strong>。网页主要由文字、图像和超链接等元素构成。当然，除了这些元素，网页中还可以包含音频、视频以及Flash等。</p><p>我们在浏览器上输入网址后，打开的任何一个页面，都是属于网页。</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是网页运行的平台，常见的浏览器有谷歌（Chrome）、Safari、火狐（Firefox）、IE、Edge、Opera等。</p><p>关于浏览器的详细介绍，可以看下一篇文章：《浏览器的介绍》。</p><h2 id="Web标准"><a href="#Web标准" class="headerlink" title="Web标准"></a>Web标准</h2><h3 id="W3C组织"><a href="#W3C组织" class="headerlink" title="W3C组织"></a>W3C组织</h3><p><strong>W3C</strong>：World Wide Web Consortium，万维网联盟组织，用来制定web标准的机构（组织）。</p><p>W3C 万维网联盟是国际最著名的标准化组织。1994年成立后，至今已发布近百项相关万维网的标准，对万维网发展做出了杰出的贡献。</p><p>W3C 组织就类似于现实世界中的联合国。</p><p>为什么要遵循WEB标准呢？因为很多浏览器的浏览器内核不同，导致页面解析出来的效果可能会有差异，给开发者增加无谓的工作量。因此需要指定统一的标准。</p><h3 id="Web-标准"><a href="#Web-标准" class="headerlink" title="Web 标准"></a>Web 标准</h3><p><strong>Web标准</strong>：制作网页要遵循的规范。</p><p>Web标准不是某一个标准，而是由W3C组织和其他标准化组织制定的一系列标准的集合。</p><p><strong>1、Web标准包括三个方面</strong>：</p><ul><li><p>结构标准（HTML）：用于对网页元素进行整理和分类。</p></li><li><p>表现标准（CSS）：用于设置网页元素的版式、颜色、大小等外观样式。</p></li><li><p>行为标准（JS）：用于定义网页的交互和行为。</p></li></ul><p>根据上面的Web标准，可以将 Web前端分为三层，如下。</p><p><strong>2、Web前端分三层</strong>：</p><ul><li>HTML（HyperText Markup Language）：超文本标记语言。从<strong>语义</strong>的角度描述页面的<strong>结构</strong>。相当于人的身体组织结构。</li><li>CSS（Cascading Style Sheets）：层叠样式表。从<strong>审美</strong>的角度美化页面的<strong>样式</strong>。相当于人的衣服和打扮。</li><li>JavaScript（简称JS）：从<strong>交互</strong>的角度描述页面的<strong>行为</strong>，实现业务逻辑和页面控制。相当于人的动作，让人有生命力。</li></ul><p><strong>3、打个比方</strong>：（拿黄渤举例）</p><p>HTML 相当于人的身体组织结构：</p><p><img src="http://img.smyhvae.com/20200322_1250.png"></p><p>CSS 相当于人的衣服和打扮：</p><p><img src="http://img.smyhvae.com/20200322_1251.png"></p><p>JS 相当于人的行为：</p><p><img src="http://img.smyhvae.com/20200322_2220.gif"></p><hr>]]></content>
      
      
      <categories>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端学习 </tag>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计（五）</title>
      <link href="/2024/03/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%94%EF%BC%89/"/>
      <url>/2024/03/10/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理课程设计（五）"><a href="#编译原理课程设计（五）" class="headerlink" title=" 编译原理课程设计（五）"></a><center> <strong>编译原理课程设计（五）</strong></h1><p>是的，你可以在 Windows 上使用 Flex 和 Bison。通常，你可以使用 WinFlexBison，这是为 Windows 平台提供的 Flex 和 Bison 的二进制版本。</p><p>以下是在 Windows 上使用 WinFlexBison 的步骤：</p><ol><li><p><strong>下载 WinFlexBison：</strong> 访问 <a href="https://github.com/lexxmark/winflexbison/releases">WinFlexBison GitHub Releases</a> 页面，下载最新版本的二进制文件（<code>.zip</code> 文件）。</p></li><li><p><strong>解压文件：</strong> 将下载的 <code>.zip</code> 文件解压到一个你选择的目录。</p></li><li><p><strong>设置环境变量：</strong> 将 WinFlexBison 的目录添加到系统的 PATH 环境变量中。你可以按照以下步骤之一来完成：</p><ul><li>在系统环境变量中添加 WinFlexBison 目录。</li><li>在你的项目中使用 WinFlexBison 的绝对路径。</li></ul></li><li><p><strong>创建 Lex 和 Yacc 文件：</strong> 使用 WinFlexBison 提供的 <code>win_flex</code> 和 <code>win_bison</code> 命令行工具生成 Lex 和 Yacc 文件。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">win_flex lex.l</span><br><span class="line">win_bison -d yacc.y</span><br></pre></td></tr></table></figure><p>这将生成 <code>lex.yy.c</code> 和 <code>y.tab.c</code> 文件，然后你可以将这些文件添加到你的项目中。</p></li></ol><p>请注意，WinFlexBison 提供的工具可能与标准的 Flex 和 Bison 略有不同，但通常可以满足在 Windows 上构建 Lex 和 Yacc 文件的需求。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计（四）</title>
      <link href="/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
      <url>/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理课程设计（四）"><a href="#编译原理课程设计（四）" class="headerlink" title=" 编译原理课程设计（四）"></a><center> <strong>编译原理课程设计（四）</strong></h1><p>以下是全流程步骤：</p><h2 id="1-创建项目目录："><a href="#1-创建项目目录：" class="headerlink" title="1. 创建项目目录："></a>1. <strong>创建项目目录：</strong></h2><p>   在你选择的位置创建一个新目录，例如 <code>SimpleCompiler</code>。</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> SimpleCompiler</span><br><span class="line"><span class="built_in">cd</span> SimpleCompiler</span><br></pre></td></tr></table></figure><h2 id="2-创建-Lex-文件："><a href="#2-创建-Lex-文件：" class="headerlink" title="2. 创建 Lex 文件："></a>2. <strong>创建 Lex 文件：</strong></h2><p>   在项目目录中创建 <code>lex.l</code> 文件，将下面的内容复制到文件中。</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;yacc.tab.h&quot;</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int yylval;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[ \t\n]     ; // Skip whitespace</span><br><span class="line">[a-zA-Z][a-zA-Z0-9]*   &#123;</span><br><span class="line">                          yylval = strdup(yytext);</span><br><span class="line">                          return IDENTIFIER;</span><br><span class="line">                      &#125;</span><br><span class="line">:=          return ASSIGN;</span><br><span class="line">[0-9]+      &#123;</span><br><span class="line">                          yylval = atoi(yytext);</span><br><span class="line">                          return INTEGER;</span><br><span class="line">                      &#125;</span><br><span class="line">\;          return SEMICOLON;</span><br><span class="line">\.          return PERIOD;</span><br><span class="line">.           ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><h2 id="3-创建-Yacc-文件："><a href="#3-创建-Yacc-文件：" class="headerlink" title="3. 创建 Yacc 文件："></a>3. <strong>创建 Yacc 文件：</strong></h2><p>   在项目目录中创建 <code>yacc.y</code> 文件，将下面的内容复制到文件中。</p>   <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   %&#123;</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">std::vector&lt;std::string&gt; variables; // 保存变量信息</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int yylex();</span><br><span class="line">    void yyerror(const char* s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%union &#123;</span><br><span class="line">    int intval;</span><br><span class="line">    char* strval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;intval&gt; INTEGER</span><br><span class="line">%token &lt;strval&gt; IDENTIFIER</span><br><span class="line">%token ASSIGN SEMICOLON PERIOD</span><br><span class="line"></span><br><span class="line">%start program</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">program: block PERIOD &#123;</span><br><span class="line">    printf(&quot;Compilation successful!\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block: BEGIN statement_list END &#123;</span><br><span class="line">    printf(&quot;Executing program...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statement_list: statement &#123;</span><br><span class="line">    printf(&quot;Statement executed\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">| statement_list SEMICOLON statement &#123;</span><br><span class="line">    printf(&quot;Statement executed\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statement: assignment &#123;</span><br><span class="line">    printf(&quot;Assignment statement\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assignment: IDENTIFIER ASSIGN expression &#123;</span><br><span class="line">    // 生成赋值代码</span><br><span class="line">    printf(&quot;%s = %d;\n&quot;, $1, $3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expression: INTEGER &#123;</span><br><span class="line">    $$ = $1;</span><br><span class="line">&#125;</span><br><span class="line">| IDENTIFIER &#123;</span><br><span class="line">    // 在表达式中使用变量，保存变量信息</span><br><span class="line">    variables.push_back($1);</span><br><span class="line">    $$ = lookup_variable($1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">int lookup_variable(const char* var) &#123;</span><br><span class="line">    // Dummy implementation for variable lookup</span><br><span class="line">    printf(&quot;Looking up variable %s\n&quot;, var);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Simple Pascal Compiler\n&quot;);</span><br><span class="line">    yyparse();</span><br><span class="line"></span><br><span class="line">    // 打印变量信息</span><br><span class="line">    printf(&quot;Variables used in the program:\n&quot;);</span><br><span class="line">    for (const std::string&amp; var : variables) &#123;</span><br><span class="line">        printf(&quot;%s\n&quot;, var.c_str());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="4-创建主文件："><a href="#4-创建主文件：" class="headerlink" title="4. 创建主文件："></a>4. <strong>创建主文件：</strong></h2><p>   在项目目录中创建 <code>main.cpp</code> 文件，将下面的内容复制到文件中。</p>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;main.h&quot;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yylex</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">yyparse</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Simple Pascal Compiler\n&quot;</span>);</span><br><span class="line">    <span class="built_in">yyparse</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-创建头文件："><a href="#5-创建头文件：" class="headerlink" title="5. 创建头文件："></a>5. <strong>创建头文件：</strong></h2><p>   在项目目录中创建 <code>main.h</code> 文件，将下面的内容复制到文件中。</p>   <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MAIN_HPP</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAIN_HPP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> YYSTYPE Type</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Type</span> &#123;</span><br><span class="line">    <span class="type">int</span> intval;</span><br><span class="line">    <span class="type">char</span>* strval;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h2 id="6-创建-CMakeLists-txt-文件："><a href="#6-创建-CMakeLists-txt-文件：" class="headerlink" title="6. 创建 CMakeLists.txt 文件："></a>6. <strong>创建 CMakeLists.txt 文件：</strong></h2><p>   在项目目录中创建 <code>CMakeLists.txt</code> 文件，将下面的内容复制到文件中。</p>   <figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">project</span>(SimpleCompiler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Find Flex and Bison</span></span><br><span class="line"><span class="keyword">find_package</span>(FLEX REQUIRED)</span><br><span class="line"><span class="keyword">find_package</span>(BISON REQUIRED)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Generate Lex and Yacc files</span></span><br><span class="line">FLEX_TARGET(MyScanner lex.l <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/lex.yy.c)</span><br><span class="line">BISON_TARGET(MyParser yacc.y <span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>/y.tab.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add Flex and Bison output files to the project</span></span><br><span class="line">ADD_FLEX_BISON_DEPENDENCY(MyScanner MyParser)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Include directories</span></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;CMAKE_CURRENT_BINARY_DIR&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create executable</span></span><br><span class="line"><span class="keyword">add_executable</span>(simple_compiler main.cpp <span class="variable">$&#123;FLEX_MyScanner_OUTPUTS&#125;</span> <span class="variable">$&#123;BISON_MyParser_OUTPUTS&#125;</span>)</span><br></pre></td></tr></table></figure><h2 id="7-构建项目："><a href="#7-构建项目：" class="headerlink" title="7. 构建项目："></a>7. <strong>构建项目：</strong></h2><p>   打开终端，进入项目目录，然后运行以下命令构建项目。</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build</span><br><span class="line">cmake ..</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>   这将在 <code>build</code> 文件夹中生成一个名为 <code>simple_compiler</code> 的可执行文件。</p><h2 id="8-运行编译器："><a href="#8-运行编译器：" class="headerlink" title="8. 运行编译器："></a>8. <strong>运行编译器：</strong></h2><p>   在终端中，你可以使用以下命令运行生成的编译器，并将 Pascal 代码作为输入。</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./simple_compiler</span><br></pre></td></tr></table></figure><p>   编译器会提示 “Simple Pascal Compiler”，然后等待输入。你可以输入Pascal代码并按Ctrl+D结束输入。</p><p>请注意，由于我们的示例编译器没有实际的代码生成，它只输出一些信息以演示流程。在实际编译器中，你需要更多的规则来覆盖Pascal语言的其他方面，并生成实际的目标代码。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计（三）</title>
      <link href="/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/"/>
      <url>/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理课程设计（三）"><a href="#编译原理课程设计（三）" class="headerlink" title=" 编译原理课程设计（三）"></a><center> <strong>编译原理课程设计（三）</strong></h1><h2 id="运行这个简易的编译器需要一些步骤。以下是基本的流程："><a href="#运行这个简易的编译器需要一些步骤。以下是基本的流程：" class="headerlink" title="运行这个简易的编译器需要一些步骤。以下是基本的流程："></a>运行这个简易的编译器需要一些步骤。以下是基本的流程：</h2><h3 id="1-安装-Flex-和-Bison："><a href="#1-安装-Flex-和-Bison：" class="headerlink" title="1. 安装 Flex 和 Bison："></a>1. <strong>安装 Flex 和 Bison：</strong></h3><p>   你需要确保系统上安装了 Flex 和 Bison。它们是用于生成词法分析器和语法分析器的工具。你可以通过包管理器安装它们，例如在 Ubuntu 上使用以下命令：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install flex bison</span><br></pre></td></tr></table></figure><p>   对于其他系统，请使用相应的包管理器进行安装。</p><h3 id="2-编译-Lex-和-Yacc-文件："><a href="#2-编译-Lex-和-Yacc-文件：" class="headerlink" title="2. 编译 Lex 和 Yacc 文件："></a>2. <strong>编译 Lex 和 Yacc 文件：</strong></h3><p>   打开终端，进入包含 <code>lex.l</code> 和 <code>yacc.y</code> 文件的目录，然后运行以下命令编译它们：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">flex lex.l</span><br><span class="line">bison -dy yacc.y</span><br></pre></td></tr></table></figure><p>   这将生成 <code>lex.yy.c</code> 和 <code>y.tab.c</code> 文件。</p><h3 id="3-编译和链接："><a href="#3-编译和链接：" class="headerlink" title="3. 编译和链接："></a>3. <strong>编译和链接：</strong></h3><p>   继续在终端中运行以下命令编译和链接程序：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">g++ -o simple_compiler lex.yy.c y.tab.c main.cpp</span><br></pre></td></tr></table></figure><p>   这将生成可执行文件 <code>simple_compiler</code>。</p><h3 id="4-运行程序："><a href="#4-运行程序：" class="headerlink" title="4. 运行程序："></a>4. <strong>运行程序：</strong></h3><p>   运行生成的编译器，并将 Pascal 代码作为输入：</p>   <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./simple_compiler &lt; input.pas</span><br></pre></td></tr></table></figure><p>   其中 <code>input.pas</code> 是包含 Pascal 代码的文件。在这个示例中，你可以使用提供的简单 Pascal 代码。</p><p>请注意，这个简易的编译器只是演示流程的一部分，实际编译器需要更复杂的处理，包括错误处理、代码生成等。此外，由于我们的示例不生成实际的目标代码，程序输出的信息主要用于演示流程和调试目的。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计（二）</title>
      <link href="/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理课程设计（二）"><a href="#编译原理课程设计（二）" class="headerlink" title=" 编译原理课程设计（二）"></a><center> <strong>编译原理课程设计（二）</strong></h1><p>以下是一个简单的示例，以演示整个流程。我们将创建一个支持如下形式的Pascal代码：</p><figure class="highlight pascal"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> SimpleCompiler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span></span><br><span class="line">  a, b: integer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span></span><br><span class="line">  a := <span class="number">5</span>;</span><br><span class="line">  b := <span class="number">10</span>;</span><br><span class="line"><span class="keyword">end</span>.</span><br></pre></td></tr></table></figure><p>这个Pascal代码定义了两个整数变量 <code>a</code> 和 <code>b</code>，并给它们分别赋值为 5 和 10。</p><p>让我们从头开始，首先是 <code>lex.l</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">#include &quot;yacc.tab.h&quot;</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int yylval;</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%option noyywrap</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">[ \t\n]     ; // Skip whitespace</span><br><span class="line">[a-zA-Z][a-zA-Z0-9]*   &#123;</span><br><span class="line">                          yylval = strdup(yytext);</span><br><span class="line">                          return IDENTIFIER;</span><br><span class="line">                      &#125;</span><br><span class="line">:=          return ASSIGN;</span><br><span class="line">[0-9]+      &#123;</span><br><span class="line">                          yylval = atoi(yytext);</span><br><span class="line">                          return INTEGER;</span><br><span class="line">                      &#125;</span><br><span class="line">\;          return SEMICOLON;</span><br><span class="line">\.          return PERIOD;</span><br><span class="line">.           ;</span><br><span class="line">%%</span><br></pre></td></tr></table></figure><p>在这个简单的 <code>lex.l</code> 文件中，我们定义了标识符、赋值符号 <code>:=</code>、整数、分号 <code>;</code>、句点 <code>.</code> 等的词法规则。这里使用了一些简化，比如忽略了空白和换行符。</p><p>接下来是 <code>yacc.y</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%&#123;</span><br><span class="line">#include &quot;main.h&quot;</span><br><span class="line">extern &quot;C&quot; &#123;</span><br><span class="line">    int yylex();</span><br><span class="line">    void yyerror(const char* s);</span><br><span class="line">&#125;</span><br><span class="line">%&#125;</span><br><span class="line"></span><br><span class="line">%union &#123;</span><br><span class="line">    int intval;</span><br><span class="line">    char* strval;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%token &lt;intval&gt; INTEGER</span><br><span class="line">%token &lt;strval&gt; IDENTIFIER</span><br><span class="line">%token ASSIGN SEMICOLON PERIOD</span><br><span class="line"></span><br><span class="line">%start program</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line">program: block PERIOD &#123;</span><br><span class="line">    printf(&quot;Compilation successful!\n&quot;);</span><br><span class="line">    exit(0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block: BEGIN statement_list END &#123;</span><br><span class="line">    printf(&quot;Executing program...\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statement_list: statement &#123;</span><br><span class="line">    printf(&quot;Statement executed\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line">| statement_list SEMICOLON statement &#123;</span><br><span class="line">    printf(&quot;Statement executed\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">statement: assignment &#123;</span><br><span class="line">    printf(&quot;Assignment statement\n&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">assignment: IDENTIFIER ASSIGN expression &#123;</span><br><span class="line">    printf(&quot;Assigning value to %s\n&quot;, $1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expression: INTEGER &#123;</span><br><span class="line">    $$ = $1;</span><br><span class="line">&#125;</span><br><span class="line">| IDENTIFIER &#123;</span><br><span class="line">    $$ = lookup_variable($1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">%%</span><br><span class="line"></span><br><span class="line">void yyerror(const char* s) &#123;</span><br><span class="line">    fprintf(stderr, &quot;Error: %s\n&quot;, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int lookup_variable(const char* var) &#123;</span><br><span class="line">    // Dummy implementation for variable lookup</span><br><span class="line">    printf(&quot;Looking up variable %s\n&quot;, var);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    printf(&quot;Simple Pascal Compiler\n&quot;);</span><br><span class="line">    yyparse();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个简单的 <code>yacc.y</code> 文件定义了一个非常基本的语法，其中包含程序、块、语句列表、语句和赋值语句等。为了简化，这个编译器不执行实际的代码生成，而是输出一些信息表示语法分析和语义分析的阶段。实际的编译器需要更复杂的处理和数据结构来生成目标代码。</p><p>在这个示例中，我们使用了一个虚构的 <code>lookup_variable</code> 函数来模拟变量查找。在实际编译器中，这将是符号表的一部分，并用于跟踪和查找变量。</p><p>这个简单的编译器仅演示了Pascal语法的一小部分，且没有进行实际的代码生成。在实际的编译器中，将需要更多的规则来覆盖Pascal语言的其他方面，以及生成实际的目标代码。</p><p>可以按照这个基础示例继续扩展编译器，以处理更多的Pascal语法和语义规则。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译原理课程设计（一）</title>
      <link href="/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/"/>
      <url>/2024/03/07/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E8%AF%BE%E7%A8%8B%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="编译原理课程设计（一）"><a href="#编译原理课程设计（一）" class="headerlink" title=" 编译原理课程设计（一）"></a><center> <strong>编译原理课程设计（一）</strong></h1><h2 id="流程大致如下："><a href="#流程大致如下：" class="headerlink" title="流程大致如下："></a><strong>流程大致如下：</strong></h2><h3 id="1-词法分析（Lex）："><a href="#1-词法分析（Lex）：" class="headerlink" title="1. 词法分析（Lex）："></a>1. <strong>词法分析（Lex）：</strong></h3><ul><li>使用Lex工具对Pascal源代码进行词法分析，将源代码转换为记号序列。</li><li>在 <code>lex.l</code> 文件中定义正则表达式规则，匹配Pascal中的标识符、整数、运算符等记号。</li><li>通过 <code>yylval</code> 结构体传递识别出的记号的值，其中 <code>YYSTYPE</code> 被重定义为 <code>struct Type</code>，可以存储多种信息。</li></ul><h3 id="2-语法分析（Yacc）："><a href="#2-语法分析（Yacc）：" class="headerlink" title="2. 语法分析（Yacc）："></a>2. <strong>语法分析（Yacc）：</strong></h3><ul><li>使用Yacc工具对Pascal源代码进行语法分析，构建语法树。</li><li>在 <code>yacc.y</code> 文件中定义语法规则，描述Pascal中的语法结构，同时通过 <code>%token</code> 和 <code>%type</code> 声明记号和非终结符的属性。</li><li>使用动作代码构建抽象语法树，将 <code>$$</code> 和 <code>$1</code> 等符号映射到 <code>YYSTYPE</code> 结构体中的成员，将记号的属性传递给语法树节点。</li></ul><h3 id="3-生成语法树（AST）："><a href="#3-生成语法树（AST）：" class="headerlink" title="3. 生成语法树（AST）："></a>3. <strong>生成语法树（AST）：</strong></h3><ul><li>在 <code>yacc.y</code> 文件中定义产生式和相应的动作代码，以构建抽象语法树。</li><li>语法树的节点类型和属性由 <code>YYSTYPE</code> 结构体中的成员决定，如标识符、整数、运算符等。</li></ul><h3 id="4-代码生成："><a href="#4-代码生成：" class="headerlink" title="4. 代码生成："></a>4. <strong>代码生成：</strong></h3><ul><li>遍历抽象语法树，将每个节点翻译为等效的C语言代码。</li><li>在 <code>yacc.y</code> 文件中定义语法规则时，通过动作代码将翻译后的C代码输出或执行。</li><li>对于不同的语法结构，可能需要生成不同的C代码，考虑Pascal和C之间的差异。</li></ul><h3 id="5-整体流程："><a href="#5-整体流程：" class="headerlink" title="5. 整体流程："></a>5. <strong>整体流程：</strong></h3><ul><li>主函数 (<code>main</code>) 初始化输入文件，调用 <code>yyparse()</code> 开始语法分析过程。</li><li>Lex的 <code>yylex()</code> 函数读取记号序列，Yacc按照语法规则进行分析。</li><li>在分析的过程中，动作代码构建抽象语法树，同时输出或执行相应的C代码。</li><li>在语法分析结束后，得到翻译后的C代码。</li></ul><p>总体来说，该流程涵盖了从Pascal到C的编译器设计的主要步骤，包括词法分析、语法分析、生成抽象语法树以及最终的代码生成。在具体实现时，需要根据Pascal语言的语法和语义规则以及C语言的特性进行详细设计和实现。</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程设计 </tag>
            
            <tag> 编译原理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/03/02/test/"/>
      <url>/2024/03/02/test/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo回归测试"><a href="#hexo回归测试" class="headerlink" title=" hexo回归测试"></a><center> hexo回归测试</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>test</p>]]></content>
      
      
      <categories>
          
          <category> 博客设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/03/02/hello-world/"/>
      <url>/2024/03/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android studio|关于gridview的使用</title>
      <link href="/2023/03/20/Android-studio-%E5%85%B3%E4%BA%8Egridview%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/2023/03/20/Android-studio-%E5%85%B3%E4%BA%8Egridview%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Android-studio-关于gridview的使用"><a href="#Android-studio-关于gridview的使用" class="headerlink" title=" Android studio|关于gridview的使用"></a><center> Android studio|关于gridview的使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>当你需要在你的Android应用程序中显示一组类似于网格的数据时，可以使用GridView组件。GridView是一个在Android Studio中预定义的可重复使用组件，可以让你轻松地以网格形式显示数据。   </p><h2 id="一般步骤"><a href="#一般步骤" class="headerlink" title="一般步骤"></a>一般步骤</h2><p>1.在你的XML布局文件中添加GridView组件。</p><p>2.创建一个类来表示每个单元格的数据（例如一个简单的Java类）。</p><p>3.创建一个类来实现Adapter接口并定义如何将数据绑定到单元格视图。</p><p>4.创建一个数据列表，并创建一个Adapter对象，将列表数据与GridView组件绑定。   </p><h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>下面是一个简单的例子，演示如何在Android Studio中使用GridView：   </p><h3 id="在XML布局文件中添加GridView组件："><a href="#在XML布局文件中添加GridView组件：" class="headerlink" title="在XML布局文件中添加GridView组件："></a>在XML布局文件中添加GridView组件：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;GridView</span><br><span class="line">    android:id=&quot;@+id/grid_view&quot;</span><br><span class="line">    android:layout_width=&quot;match_parent&quot;</span><br><span class="line">    android:layout_height=&quot;match_parent&quot;</span><br><span class="line">    android:numColumns=&quot;3&quot;</span><br><span class="line">    android:verticalSpacing=&quot;10dp&quot;</span><br><span class="line">    android:horizontalSpacing=&quot;10dp&quot;</span><br><span class="line">    android:stretchMode=&quot;columnWidth&quot;</span><br><span class="line">    android:gravity=&quot;center&quot;</span><br><span class="line">    /&gt;</span><br></pre></td></tr></table></figure><p>这个布局文件定义了一个GridView组件，它将显示3列数据，每个单元格之间有10dp的垂直和水平间距。’android:stretchMode’属性设置为’columnWidth’，这样每个单元格的宽度都会根据列宽度平均分配。</p><h3 id="创建一个类来表示每个单元格的数据，例如一个简单的Java类："><a href="#创建一个类来表示每个单元格的数据，例如一个简单的Java类：" class="headerlink" title="创建一个类来表示每个单元格的数据，例如一个简单的Java类："></a>创建一个类来表示每个单元格的数据，例如一个简单的Java类：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GridItem &#123;</span><br><span class="line">    private int image;</span><br><span class="line">    private String title;</span><br><span class="line">    </span><br><span class="line">    public GridItem(int image, String title) &#123;</span><br><span class="line">        this.image = image;</span><br><span class="line">        this.title = title;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int getImage() &#123;</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public String getTitle() &#123;</span><br><span class="line">        return title;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类表示每个单元格的数据，包括图像和标题。</p><h3 id="创建一个类来实现Adapter接口并定义如何将数据绑定到单元格视图："><a href="#创建一个类来实现Adapter接口并定义如何将数据绑定到单元格视图：" class="headerlink" title="创建一个类来实现Adapter接口并定义如何将数据绑定到单元格视图："></a>创建一个类来实现Adapter接口并定义如何将数据绑定到单元格视图：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class GridAdapter extends BaseAdapter &#123;</span><br><span class="line">    private Context context;</span><br><span class="line">    private List&lt;GridItem&gt; items;</span><br><span class="line">    </span><br><span class="line">    public GridAdapter(Context context, List&lt;GridItem&gt; items) &#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.items = items;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public int getCount() &#123;</span><br><span class="line">        return items.size();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public Object getItem(int position) &#123;</span><br><span class="line">        return items.get(position);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public long getItemId(int position) &#123;</span><br><span class="line">        return position;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public View getView(int position, View convertView, ViewGroup parent) &#123;</span><br><span class="line">        View view = convertView;</span><br><span class="line">        ViewHolder holder;</span><br><span class="line">        if (view == null) &#123;</span><br><span class="line">            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line">            view = inflater.inflate(R.layout.grid_item, parent, false);</span><br><span class="line">            holder = new ViewHolder();</span><br><span class="line">            holder.imageView = (ImageView) view.findViewById(R.id.image);</span><br><span class="line">            holder.titleView = (TextView) view.findViewById(R.id.title);</span><br><span class="line">            view.setTag(holder);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            holder = (ViewHolder) view.getTag();</span><br><span class="line">        &#125;</span><br><span class="line">        GridItem item = items.get(position);</span><br><span class="line">        holder.imageView.setImageResource(item.getImage());</span><br><span class="line">        holder.titleView.setText(item.getTitle());</span><br><span class="line">        return view;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 安卓开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -安卓开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用|新建文章</title>
      <link href="/2023/03/20/hexo%E4%BD%BF%E7%94%A8-%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2023/03/20/hexo%E4%BD%BF%E7%94%A8-%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="hexo使用-新建文章"><a href="#hexo使用-新建文章" class="headerlink" title=" hexo使用|新建文章"></a><center> hexo使用|新建文章</h1><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>1.新建文章很简单，一条命令即可。命令如下，执行命令成功会返回一个路径，就是文章的所在路径，删除文章也只要删除对应的文章文件即可。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new 文章文件名</span><br></pre></td></tr></table></figure><p>2.新建草稿命令如下，草稿不会在博客上显示。在执行时加上 –draft 参数，或是把草稿中render_drafts参数设为true来预览草稿。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new draft 草稿文件名</span><br></pre></td></tr></table></figure><p>3.新建导航选项页界面</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo new page 导航选项页文件名</span><br></pre></td></tr></table></figure><h2 id="发布草稿"><a href="#发布草稿" class="headerlink" title="发布草稿"></a>发布草稿</h2><p>草稿是不会显示到博客上面的，有两张方法发布草稿为正式文章</p><p>1、通过命令</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo publish 文章文件名</span><br></pre></td></tr></table></figure><p>2.通过移动</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">手动将“_drafts”目录下的草稿移动到“_posts”目录下即可发布草稿为正式文章。</span><br></pre></td></tr></table></figure><h2 id="添加分类和标签"><a href="#添加分类和标签" class="headerlink" title="添加分类和标签"></a>添加分类和标签</h2><p>文章分类和标签在文章中添加，文章的参数列表如下：</p><table><thead><tr><th align="center">参数</th><th align="center">描述</th><th align="center">默认值</th></tr></thead><tbody><tr><td align="center">layout</td><td align="center">布局</td><td align="center"></td></tr><tr><td align="center">title</td><td align="center">标题</td><td align="center">文章的文件名</td></tr><tr><td align="center">date</td><td align="center">建立日期</td><td align="center">文章建立日期</td></tr><tr><td align="center">updated</td><td align="center">更新日期</td><td align="center">文件更新日期</td></tr><tr><td align="center">comments</td><td align="center">开启文章的评论功能</td><td align="center">true</td></tr><tr><td align="center">tags</td><td align="center">标签</td><td align="center"></td></tr><tr><td align="center">cate</td><td align="center">分类</td><td align="center"></td></tr><tr><td align="center">permalink</td><td align="center">覆盖文章网址</td><td align="center"></td></tr></tbody></table><p>3.1添加分类</p><p>参数“categories”表示分类，一篇文章只能属于一个分类，如果添加了多个分类，则下一个分类为子分类。<br>添加分类的格式如下</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories:</span><br><span class="line">- 分类</span><br><span class="line">- 子分类</span><br><span class="line">- 子子分类</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 博客设置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -博客 -hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/03/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/03/15/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="第一篇博客"><a href="#第一篇博客" class="headerlink" title="第一篇博客"></a>第一篇博客</h1><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>…</p><h2 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h2>]]></content>
      
      
      <categories>
          
          <category> 主题优化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
            <tag> 测试 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
